#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp(ql:quickload '(clingon cl-ppcre fiveam uiop) :silent t)
  )

(defpackage :ros.script.easytree
  (:use :cl))
(in-package :ros.script.easytree)


(defun dbg (s x) (format t "*** TRACE[~A]: ~S~% ***" s x) x)


(defun implies (a b)
  "Implication: a -> b"
  (or (not a) b))


(defun starts-with-p (STRING PREFIX &key CASE-INSENSITIVE)
  "Check that `string` starts with `PREFIX`"
  (and (<= (length PREFIX) (length STRING))
       (if CASE-INSENSITIVE
           (string-equal PREFIX (subseq STRING 0 (length PREFIX)))
           (string= PREFIX (subseq STRING 0 (length PREFIX)) :start1 0 :start2 0))))


(defun ch-at (STRING I)
  (let ((len (length STRING)))
    (cond
      ((or (< I (- len)) (>= I len)) nil)
      ((< I 0) (char STRING (+ len I)))
      (t (char STRING I)))))


(deftype <fsobj> () '(member :file :dir))

(defconstant +formats+ '(:tree :find :ls1r :ls1rl))
(deftype <format> ()
  `(member nil ,@ +formats+))

(defun other-formats (FORMAT)
  "Returns all +formats+ except FORMAT"
  (remove-if (lambda (fmt) (eq fmt FORMAT)) +formats+))

(defstruct <parsed-line>
  (format nil :type <format>)
  (fname "" :type string)
  (fmode 0 :type integer)
  (fsobj :file :type <fsobj>))

(defstruct <tree-state>
  ;; Stack of indents in a tree directory representation,it is not 1,2,3, but any integers.
  ;; It's a list, not just one integer, bcs we can decrease depth from 30 to 12 and, if it
  ;; is an integer, we cannot know how many dirs we exited: one 30->12, two 30->20->12, ...
  (indents nil
   :type list)
  ;; Stack of file/dir names in a tree directory representation
  (fnames nil
   :type list))

(defstruct <parsed-lines>
  ;; (number 0 :type integer)
  (detected-format nil :type <format>)
  (dir-from-final-slash t :type boolean)
  (as-tree nil :type list)  ;; list of <parsed-line>
  (as-find nil :type list)
  (as-ls1r nil :type list)
  (as-ls1rl nil :type list)
  (tree-state nil :type <tree-state>))

(declaim (ftype (function (<parsed-lines> <format>) list) get-parsed-lines))
(defun get-parsed-lines (PARSED-LINES FORMAT)
  (ecase FORMAT
    (:tree (<parsed-lines>-as-tree PARSED-LINES))
    (:find (<parsed-lines>-as-find PARSED-LINES))
    (:ls1r (<parsed-lines>-as-ls1r PARSED-LINES))
    (:ls1rl (<parsed-lines>-as-ls1rl PARSED-LINES))))

(defun get-cons-with-longest-list (conses)
  "Returns a list of cons-es with the longest cdr:

CL-USER> (get-cons-with-longest-list '((1 2 3) (2 11 12 13)))
((2 11 12 13))
CL-USER> (get-cons-with-longest-list '((1 2 3) (2 11 12)))
((1 2 3) (2 11 12))
"
  (reduce (lambda (res cons-i)
            (let* ((parsed-lines-i (cdr cons-i))
                   (parsed-lines-i-len (length parsed-lines-i))
                   (parsed-lines-max-len (if res (length (cdar res)) 0)))
              (cond ((null res) (list cons-i))
                    ((> parsed-lines-i-len parsed-lines-max-len)
                     (list cons-i))
                    ((= parsed-lines-i-len parsed-lines-max-len)
                     (append res (list cons-i)))
                    (t res))))
          conses
          :initial-value nil))

(declaim (ftype (function (<parsed-lines>) list) get-most-parsed-lines))
(defun get-most-parsed-lines (PARSED-LINES)
  "Returns a list of the longest lists of accumulated <parsed-line> items
in a form (<format> . lines-list)"
  (get-cons-with-longest-list
   (mapcar (lambda (fmt)
             (cons fmt (get-parsed-lines PARSED-LINES fmt)))
           +formats+)))

(declaim (ftype (function (<parsed-lines> <format> list) list) set-parsed-lines))
(defun set-parsed-lines (PARSED-LINES FORMAT NEW-VALUE)
  (ecase FORMAT
    (:tree (setf (<parsed-lines>-as-tree PARSED-LINES) NEW-VALUE))
    (:find (setf (<parsed-lines>-as-find PARSED-LINES) NEW-VALUE))
    (:ls1r (setf (<parsed-lines>-as-ls1r PARSED-LINES) NEW-VALUE))
    (:ls1rl (setf (<parsed-lines>-as-ls1rl PARSED-LINES) NEW-VALUE))))

(declaim (ftype (function (<parsed-lines> <format> <parsed-line>) list) add-to-parsed-lines))
(defun add-to-parsed-lines (PARSED-LINES FORMAT PARSED-LINE)
  "Adds a <parsed-line> to <parsed-lines> FORMAT (relies on a callee that it will
not add it to wrong FORMAT)"
  (let* ((lines (get-parsed-lines PARSED-LINES FORMAT))
         (new-lines (append lines (list PARSED-LINE))))
    (set-parsed-lines PARSED-LINES FORMAT new-lines)))

;; (declaim (ftype (function (<parsed-lines> list) (or null list)) add-to-actively-parsed-lines))
;; (defun add-to-actively-parsed-lines (PARSED-LINES RESULTS)
;;   "Puts results, list of cons-es `(<format> . <parsed-line>)`, to <parsed-lines> if it is
;; possible yet (there are yet actively collecting <parsed-line> lists)"
;;   (let* ((already-lines (<parsed-lines>-number PARSED-LINES))
;;          (results-to-add
;;            (remove-if-not
;;             (lambda (result)
;;               (destructuring-bind (fmt parsed-line) result
;;                 (declare (ignore parsed-line))
;;                 (eql already-lines (length (get-parsed-lines PARSED-LINES fmt)))))
;;             RESULTS))
;;          (updated (mapcar (lambda (result)
;;                             (destructuring-bind (fmt parsed-line) result
;;                               (add-to-parsed-lines PARSED-LINES fmt parsed-line)))
;;                           results-to-add)))
;;     updated))

(defun pop-until (stack pred &key include)
  "Pops items from the head of the list (stack) optionally including the found item.
The item is looking for using a predicate function:

CL-USER> (pop-until '(1 2 3 4 5) (lambda (x) (= x 1)) :include t)
(2 3 4 5)
"
  (let* ((pos (position-if pred stack))
         (pos1 (when pos (if include (1+ pos) pos))))
    (when pos (values (subseq stack pos1) pos1))))

(defun eq-to (el &key (test #'equal))
  "Returns a function comparing any value to `el` using a test function (default #'equal).
It can be used together with (pop-until ...)
"
  (lambda (x) (funcall test el x)))


(defun append-to-path (entries entry &key sep)
  "Append dir/file `entry` to a list of dirs `entries` optionally using
a path separator `sep` (default: /), returns result string"
  (reduce (lambda (e1 e2) (concatenate 'string e1 (or sep "/") e2))
          (append entries (list entry))))

(defun to-path (entries &key sep)
  "Converts dir/file entries to a string using optional path separator `sep` (default: /)"
  (reduce (lambda (e1 e2) (concatenate 'string e1 (or sep "/") e2))
          entries))


(declaim (ftype (function (<parsed-lines> string) (or null <parsed-line>)) parse-line-as-tree))
(declaim (ftype (function (<parsed-lines> string) (or null <parsed-line>)) parse-line-as-find))
(declaim (ftype (function (<parsed-lines> string) (or null <parsed-line>)) parse-line-as-ls1r))
(declaim (ftype (function (<parsed-lines> string) (or null <parsed-line>)) parse-line-as-ls1rl))

(defun parse-line-as-tree (PARSED-LINES STR)
  "Detects that the line looks as a line from `tree`-like output. Returns
  NIL (not `tree`-like line) or '((:spaces . <spaces-num-before-file-after-decoration>))"
  (let* ((i 0) (j 0) (last-i (1- (length line))) (fname "")) ;; TODO Rename i,j
    (when
        (and (> last-i 0)
             (char/= #\: (ch-at line last-i))
             ;; skip chars that are not alphanumeric (decoration lines, spaces):
             (loop :for ch = (ch-at line i)
                   :while (< i last-i)
                   :while (not (alphanumericp ch))
                   :do (incf i))
             (setf fname (subseq line i)))
      (loop :initially (setf j last-i)
            :for ch = (ch-at line j)
            :until (alphanumericp ch)
            :do (decf j)
            :finally (if (= j last-i) (setf j nil) (incf j))) ;; j=NIL|1st non-alphanum after fname
      (if j
          (setf fname (subseq line i j))  ;; w/o non-alphanum at the end
          (setf fname (subseq line i)))
      ((symbol-macrolet
           ((state-indents (<tree-state>-indents (<parsed-lines>-tree-state PARSED-LINES)))
            (state-fnames (<tree-state>-fnames (<parsed-lines>-tree-state PARSED-LINES)))
            (last-state-indent (car state-indents)))
         (when last-state-indent
           ;; depth decreased, so I have to pop items from the tree-state:
           ;; Pop indents until stacked indent = current indent (i) if the current indent < last-state-indent:
           (cond
             ((< i last-state-indent)
              (multiple-value-bind (new-indents poped-num) (pop-until state-indents (eq-to i))
                (when poped-num ;; when poped to existing indent ;; TODO what if we return to the zero-indent?
                  (setf state-indents new-indents)
                  (setf state-fnames (subseq state-fnames poped-num))
                  (setf fname (append-to-path state-fnames fname)) ;; fname is a/b/c now
                  ;; TODO find fsobj if fname ends with #\/ - but conditionally
                  ;; TODO if <parsed-lines>-dir-from-final-slash (add this slot to <parsed-lines>)
                  (make-<parsed-line> :format :tree :fname fname :fsobj :file))))
             ((> i last-state-indent)
              ;; TODO last parsed-line must be marked as dir
              (setf state-indents (cons i state-indents))
              (setf state-fnames (cons fname state-fnames))
              (setf fname (to-path state-fnames)) ;; fname is a/b/c now
              (make-<parsed-line> :format :tree :fname fname :fsobj :file))
             ((= i last-state-indent)
              (setf fname (append-to-path state-fnames fname))  ;; fname is a/b/c now
              (make-<parsed-line> :format :tree :fname fname :fsobj :file)))))))))

(defun parse-line-as-find (PARSED-LINES STR)
  ) ;; TODO

(defun parse-line-as-ls1r (PARSED-LINES STR)
  ) ;; TODO

(defun parse-line-as-ls1rl (PARSED-LINES STR)
  ) ;; TODO

(declaim (ftype (function (<format>) (function (<parsed-lines> string) (or null <parsed-line>))) get-parse-func))
(defun get-parse-func (FORMAT)
  (ecase FORMAT
    (:tree parse-line-as-tree)
    (:find parse-line-as-find)
    (:ls1r parse-line-as-ls1r)
    (:ls1rl parse-line-as-ls1rl)))

(declaim (ftype (function (string <parsed-lines>) (or null list)) parse-line))
(defun parse-line (STR PARSED-LINES)
  "Parses string STR until there are active formats (formats that still parse),
returns a list of lists (parsed strings) or null if nothing can be parsed more"
  (let* ((active-formats (get-most-parsed-lines PARSED-LINES))
         (parse-funcs (mapcar #'get-parse-func
                              (mapcar #'car active-formats)))
         (active-formats-parsed-line
           (mapcar (lambda (parse-func) (funcall parse-func PARSED-LINES STR))
                   parse-funcs))
         (done (mapcar (lambda (active-format parsed-line)
                         (when parsed-line
                           (add-to-parsed-lines PARSED-LINES (car active-format) parsed-line)))
                       active-formats
                       active-formats-parsed-line))
         done)))

;; XXX "Permission denied" containing lines must be ignored!
;; XXX Also "cannot open directory"
;; Also tree can print attributes of files
;; Also I should learn (while I detect) where file starts:
;; +-----file
;; +-----  file  <- all lines will start with the same spacing policy

;; TODO *-det must match only unique features, so `find .` will not be recognized as
;; ls. But what should match "/aaa/bbb:" then? ls -1Rl or ls -1R ?

(defun tree-line-det (line)
  "Detects that the line looks as a line from `tree`-like output. Returns
  NIL (not `tree`-like line) or '((:spaces . <spaces-num-before-file-after-decoration>))"
  (let ((i 0) (non-alphanums 0) (spaces 0) (last-i (1- (length line))))
    (when
        (and (> last-i 0)
             (char/= #\: (ch-at line last-i))
             (loop :for ch = (ch-at line i)
                   :while (< i last-i)
                   :while (not (or (alphanumericp ch) (char= ch #\/) (char= ch #\.)
                                   (char= ch #\') (char= ch #\")))
                   :do (incf non-alphanums) (incf i)
                   :finally (return (/= non-alphanums 0)))
             (loop :for j :downfrom (1- i) :to 0
                   :for ch = (ch-at line j)
                   :while (char= ch #\Space)
                   :do (incf spaces)
                   :finally (return t))
             ;; if after prev. segments there are 1+ alphanums - OK:
             (find-if #'alphanumericp line :start non-alphanums))
      (list (cons :spaces spaces)))))


(defun find-line-det (line)
  "Detects that the line looks as a line from `find`-like output"
  (let ((last-i (1- (length line))))
    (when
        (and (> last-i 0)
             (char/= #\: (ch-at line last-i))
             (or (starts-with-p line "/")
                 (starts-with-p line "./")
                 (starts-with-p line "../")
                 (starts-with-p line "'./")
                 (starts-with-p line "\"./")
                 (starts-with-p line "'../")
                 (starts-with-p line "\"../")))
      (list (cons :uniq-features 1)))))


(defparameter *unicode-whitespace-chars*
  '(#\Space #\Tab #\Newline #\Return
    #\No-break_space           ; U+00A0
    #\Ogham_space_mark         ; U+1680
    #\En_quad                  ; U+2000
    #\Em_quad                  ; U+2001
    #\En_space                 ; U+2002
    #\Em_space                 ; U+2003
    #\Three-per-em_space       ; U+2004
    #\Four-per-em_space        ; U+2005
    #\Six-per-em_space         ; U+2006
    #\Figure_space             ; U+2007
    #\Punctuation_space        ; U+2008
    #\Thin_space               ; U+2009
    #\Hair_space               ; U+200A
    #\Zero_width_space         ; U+200B
    #\Narrow_no-break_space    ; U+202F
    #\Medium_mathematical_space; U+205F
    #\Ideographic_space))      ; U+3000


(defun trim-any-whitespaces (string)
  "Like Python's str.strip()"
  (string-trim *unicode-whitespace-chars* string))

;; TODO ../ in the beginning is also possible!!!
;; ending can be @, =, etc...

(defun ls-1r-line-det (line)  ;; XXX Must be ran after `ls-1rl-line-det`
  (let ((last-i (1- (length line)))
        (uniq-features 0))
    (when
        (or
         (when (string= "" (trim-any-whitespaces line)) (incf uniq-features))
         (and (> last-i 0)
              ;; If there are spaces, the line must start with ' or " (else: not our case, T)
              (implies (find #\Space line :test #'char=) (case (ch-at line 0) (#\' t) (#\" t)))
              (case (ch-at line 0)
                ((#\' #\" #\/ #\.) t)
                (t (alphanumericp (ch-at line 0))))
              (or (and (char= #\: (ch-at line last-i))
                       (or (starts-with-p line "/")
                           (starts-with-p line "./")
                           (starts-with-p line "../")
                           (starts-with-p line "'./")
                           (starts-with-p line "\"./")
                           (starts-with-p line "'../")
                           (starts-with-p line "\"../")))
                  ;; TODO windows?
                  (char/= #\: (ch-at line last-i)))))
      (list (cons :uniq-features uniq-features)))))


(defun ls-1rl-line-det (line)
  (let* ((last-i (1- (length line)))
         (total-str "total ")
         (file-delim (case (ch-at line last-i)
                       (#\' #\')
                       (#\" #\")
                       (t #\Space)))
         (attrs 0) (i 0) (filechars 0) (mtimechars 0)
         (uniq-features 0))
    (when
        (and (> last-i 0)
             (or (and (starts-with-p line total-str) (> last-i (length total-str))
                      (digit-char-p (ch-at line (length total-str))))
                 (and (char= #\: (ch-at line last-i))
                      (or (starts-with-p line "/")
                          (starts-with-p line "./")
                          (starts-with-p line "../")
                          (starts-with-p line "'./")
                          (starts-with-p line "\"./")
                          (starts-with-p line "'../")
                          (starts-with-p line "\"../")))
                 (when
                     (and
                      ;; 17 - minimum length with minimal column sizes and 1 space-delimiter:
                      (>= last-i 17)
                      (loop :for ch = (ch-at line i)
                            :while (< i last-i)
                            :while (or (char= ch #\-) (char= ch #\r) (char= ch #\w) (char= ch #\x)
                                       (char= ch #\l) (char= ch #\b) (char= ch #\c) (char= ch #\p)
                                       (char= ch #\s) (char= ch #\D) (char= ch #\P) (char= ch #\n)
                                       (char= ch #\C) (char= ch #\M) (char= ch #\?) (char= ch #\S)
                                       (char= ch #\t) (char= ch #\T) (char= ch #\d)
                                       (char= ch #\+) (char= ch #\.) (char= ch #\@))
                            :while (char/= ch #\Space)
                            :do (incf attrs) (incf i)
                            :finally (return (or (= attrs 10) (= attrs 11))))
                      (char= (ch-at line i) #\Space)
                      (loop :for j :downfrom last-i :to 0
                            :for ch = (ch-at line j)
                            :while (or (char/= ch file-delim) (= j last-i))
                            :do (incf filechars)
                            :finally
                               (when
                                   ;; Files with spaces or '/" are quoted with "...'..." and
                                   ;; '..."...'. If file is not quoted, when we hit the space,
                                   ;; we counted file size correctly. But when we hit '/", we
                                   ;; counted the rightmost '/" and all file symbols, but not
                                   ;; the leftmost '/", to do it, we have to do yet another
                                   ;; iteration! So, when the exit-char hit by us is not space,
                                   ;; it is some quote-symbol, so increment filechars to treat
                                   ;; 'xxx' as 5 symbols, not 4
                                   (char/= ch #\Space) (incf filechars))
                               ;; (format t "'~A' (~C)~%" filechars file-delim)
                               (return (> filechars 0)))
                      (loop :for j :downfrom (- last-i filechars 1) :to 0
                            :for ch = (ch-at line j)
                            :while (or (digit-char-p ch) (char= ch #\:))
                            :do (incf mtimechars) ;; last column of mtime is HH:MM or YYYY
                            :finally (return (or (= mtimechars 4) (= mtimechars 5)))))
                   (incf uniq-features 1))))
      (list (cons :uniq-features uniq-features)))))


(defun safe-assoc (pairs kw &KEY default)
  (let ((p (and (listp pairs)
                (assoc kw (remove-if-not #'consp pairs)))))
    (if p (cdr p) default)))


(defun get-uniq-features (det-result &optional default)
  "Returns :uniq-features from a determination result, which usually is
  NIL or '((:uniq-features) <int>)...) or something else. If it cannot
  be got, then it returns `default` (NIL or passed)''"
  (safe-assoc det-result :uniq-features :default default))


(defun det-format (funcs lines)
  "Finds the function (among `funcs`, returned as an index) which is mostly satisfied
  on `lines` (at least once! Else - returns nil)"
  (let* ((aggregate-func-lines-results
           (lambda (acc e)
             (if e
                 (list (1+ (car acc)) (+ (get-uniq-features e 0) (cadr acc)))
                 acc)))
         (funcs-over-lines-results (mapcar (lambda (fn) (mapcar fn lines)) funcs))
         (funcs-results-0 (mapcar (lambda (lines-results)
                                    (reduce aggregate-func-lines-results
                                            lines-results
                                            :initial-value (list 0 0)))
                                  funcs-over-lines-results))
         ;; just enumerated (0 ...) (1 ...)... :
         (funcs-results-1 (loop :for e :in funcs-results-0
                                :for i :from 0
                                :collect (cons i e)))
         (sorted-by-hits (sort funcs-results-1
                               (lambda (a b)
                                 (or (> (car a) (car b))
                                     (and (= (car a) (car b))
                                          (> (cadr a) (cadr b)))))
                               :key #'cdr)))
    (and funcs lines (caar sorted-by-hits))))


  ;; (let* ((funcs-hits (mapcar (lambda (fn)
  ;;                              (count-if fn lines))
  ;;                            funcs))
  ;;        (max-hits-num (apply #'max funcs-hits)))
  ;;   (and (> max-hits-num 0)
  ;;        (position max-hits-num funcs-hits))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defparameter *OS* nil)

(defun det-*OS* ()
  (cond ((member :windows *features*) :windows)
        ((member :unix *features*)
         (cond ((member :darwin *features*) :mac)
               (t :unix)))
        (t (error "OS not recognized!"))))


;; Path separator (as a string)
(defparameter *path-sep* nil)

(defun det-*path-sep* ()
  (ecase *OS* (:windows "\\") (:unix "/") (:mac "/")))


;; Known dir listing formats
(defconstant +fmt+ '(:ls :find :tree))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Logic ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun detect-series (INPUT CLASSIFIERS)
  (let ((results nil)
        ;; current-result is (class-of-series . the-length-of-series):
        (current-result (cons -1 0))
        ;; objects in INPUT that cannot be classified (index in CLASSIFIERS), will be
        ;; marked with index out of bounds, ie, max allowed index + 1 (or their length):
        (unknown-class (length CLASSIFIERS))
        ;; did we classified the object using all CLASSIFIERS on the loop:
        (classified nil))
    (unless (or (null INPUT) (null CLASSIFIERS))  ;; just ignore empty INPUT/CLASSIFIERS
      (dolist (obj INPUT)
        (setf classified nil)
        (dotimes (c (length CLASSIFIERS))
          (when (funcall (nth c CLASSIFIERS) obj)
            ;; classified by the current classifier or a new one, anyway, must be marked
            ;; as classified, else it will be marked as unknown class:
            (setf classified t)
            (if (= c (car current-result))
                (setf (cdr current-result) (1+ (cdr current-result)))
                (progn
                  (unless (= -1 (car current-result))
                    (push current-result results))
                  (setf current-result (cons c 1))))))
        (unless classified
          ;; if no CLASSIFIERS recognized obj, then it will be unknown-class. But first,
          ;; we look if the current-result already is unknown-class - if yes, then we
          ;; expand it (increment its length). If it was some known classifier, we add
          ;; it to all results. Else - just replace it (such class is -1):
          (cond
            ((= -1 (car current-result))
             (setf current-result (cons unknown-class 1)))
            ((= unknown-class (car current-result))
             (setf (cdr current-result) (1+ (cdr current-result))))
            (t (push current-result results)
               (setf current-result (cons unknown-class 1)))))))
    ;; the last series, not added by new one, bcs no more iterations - chars ended:
    (unless (= -1 (car current-result))
      (push current-result results))
    (nreverse results)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Test ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(5am:def-suite :suite1 :description "EasyTree Test Suite")
(5am:in-suite :suite1)
(5am:test get-cons-with-longest-list--test1
  (5am:is (equal (get-cons-with-longest-list '((1) (2)))
                 '((1) (2)))))

(5am:test get-cons-with-longest-list--test1
  (5am:is (equal (get-cons-with-longest-list '((1 2 3) (2 11 12 13)))
                 '((2 11 12 13)))))

(5am:test get-cons-with-longest-list--test2
  (5am:is (equal (get-cons-with-longest-list '((1 2 3) (2 11 12)))
                 '((1 2 3) (2 11 12)))))

(5am:test get-cons-with-longest-list--test3
  (5am:is (equal (get-cons-with-longest-list '((1 2 3) (2 11 12) ()))
                 '((1 2 3) (2 11 12)))))

(5am:test get-cons-with-longest-list--test4
  (5am:is (equal (get-cons-with-longest-list '((1 2 3) (2 11 12) (3)))
                 '((1 2 3) (2 11 12)))))

(5am:test get-cons-with-longest-list--test5
  (5am:is (equal (get-cons-with-longest-list '((1 2 3) (2 11 12) (3 4)))
                 '((1 2 3) (2 11 12)))))

(5am:test get-cons-with-longest-list--test6
  (5am:is (equal (get-cons-with-longest-list '((1 2 3) (2 11 12) (3 4 5)))
                 '((1 2 3) (2 11 12) (3 4 5)))))

(5am:test get-cons-with-longest-list--test7
  (5am:is (equal (get-cons-with-longest-list '((1 2 3) (2 11 12) (3 4 5 6)))
                 '((3 4 5 6)))))

(5am:test pop-until--test1
  (5am:is (equal (multiple-value-list
                  (pop-until '(1 2 3 4 5) (lambda (x) (= x 4))))
                 '((4 5) 3))))

(5am:test pop-until--test2
  (5am:is (equal (multiple-value-list
                  (pop-until '(1 2 3 4 5) (lambda (x) (= x 4)) :include t))
                 '((5) 4))))

(5am:test pop-until--test3
  (5am:is (equal (multiple-value-list
                  (pop-until '(1 2 3 4 5) (lambda (x) (= x 10)) :include t))
                 '(nil))))

(5am:test pop-until--test4
  (5am:is (equal (multiple-value-list
                  (pop-until '(1 2 3 4 5) (lambda (x) (= x 5)) :include t))
                 '(nil 5))))

(5am:test pop-until--test5
  (5am:is (equal (multiple-value-list
                  (pop-until '(1 2 3 4 5) (lambda (x) (= x 5))))
                 '((5) 4))))

(5am:test pop-until--test6
  (5am:is (equal (multiple-value-list
                  (pop-until '(1 2 3 4 5) (lambda (x) (= x 1))))
                 '((1 2 3 4 5) 0))))

(5am:test pop-until--test7
  (5am:is (equal (multiple-value-list
                  (pop-until '(1 2 3 4 5) (lambda (x) (= x 1)) :include t))
                 '((2 3 4 5) 1))))

(5am:test pop-until--test8
  (5am:is (equal (multiple-value-list
                  (pop-until '(1 2 3 4 5) (eq-to 3) :include t))
                 '((4 5) 3))))

(5am:test append-to-path--test1
  (5am:is (equal (append-to-path '("aa" "bb") "cc")
                 "aa/bb/cc")))

(5am:test append-to-path--test2
  (5am:is (equal (append-to-path '("aa" "bb") "cc" :sep "#")
                 "aa#bb#cc")))

(5am:test to-path--test1
  (5am:is (equal (to-path '("aaa" "bbb"))
                 "aaa/bbb")))

(5am:test to-path--test2
  (5am:is (equal (to-path '("aaa" "bbb") :sep "!")
                 "aaa!bbb")))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Command line ;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun cli-tests-handler (cmd)
  (declare (ignorable cmd))
  (uiop:symbol-call :fiveam :run! :suite1))
  ;; (sijo-doctest:test :ros.script.easytree))

(defun cli-convert-cmd-handler (cmd)
  (declare (ignorable cmd)))

(defun cli-convert-cmd-opts ()
  (list
   (clingon:make-option
    :choice
    :description "Input format (from)"
    :short-name #\f
    :long-name "from"
    :key :from
    :items +fmt+)
   (clingon:make-option
    :choice
    :description "Output format (to)"
    :short-name #\t
    :long-name "to"
    :key :to
    :items +fmt+)
   (clingon:make-option
    :string
    :description "Strip paths by PREFIX (N dirs, string dir)"
    :short-name #\s
    :long-name "strip"
    :key :strip)
   (clingon:make-option
    :string
    :description "Prepend paths with common directory-prefix"
    :short-name #\p
    :long-name "prepend"
    :key :prepend)))

(defun cli-tests-cmd ()
  (clingon:make-command
   :name "tests"
   :usage "<no args>"
   :description "Run tests"
   :handler #'cli-tests-handler))

(defun cli-convert-cmd ()
  (clingon:make-command
   :name "convert"
   :usage "[-f FMT] -t FMT [-s N,DIR] [-p DIR]" ;; --strip DIR/<int> --rebase DIR
   :examples '(("Convert from one format to another:" . "ls|convert -f LS -t TREE -")
               ("Convert from unknown format to another:" . "tree|convert -t TREE -")
               ("Convert from unknown format to another:" . "tree|convert -f AUTO -t FIND -"))
   :description "Convert a tree from one format to another one"
   :handler #'cli-convert-cmd-handler
   :options (cli-convert-cmd-opts)))


(defun cli-main-cmd (argv0)
  (declare (ignorable argv0))
  (clingon:make-command
   :name "tree"
   :description "File system tree"
   :version "0.1.0"
   :authors '("John Doe <john.doe@example.org>")
   :license "BSD 2-Clause"
   :sub-commands (list (cli-convert-cmd) (cli-tests-cmd))
   :handler (lambda (cmd)
              (format t "No known subcommand provided!~%~%")
              (clingon:print-usage cmd *standard-output*)
              (uiop:quit 1))))


;; convert -f AUTO|FIND|LS|TREE -t FIND|LS|TREE
;; union|intersect|diff|uniq -f AUTO|FIND|LS|TREE -f AUTO|FIND|LS|TREE
;; over -f AUTO|FIND|LS|TREE -t FIND|LS|TREE -c <CMD>|ENSURE|DELETE

(defun full-argv ()
  (or
   #+sbcl sb-ext:*posix-argv*
   #+clisp ext:*args*
   #+cmu extensions:*command-line-words*
   #+allegro (sys:command-line-arguments)
   #+lispworks system:*line-arguments-list*
   nil))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Main ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun process-argv (argv)
  (let* ((fargv (full-argv))
         (buf (make-string 3))
         (arg0-file-header (handler-case ;; if we cannot read, return fake 3 item string
                            (with-open-file (strm (car argv) :direction :input)
                              (and (read-sequence buf strm) buf))
                             (error () (make-string 3)))))
    (cond ((string= "#!/" (subseq arg0-file-header 0 3)) (list :script (car argv)))
          (t (list :binary (car fargv))))))


(defun main (&rest argv)
  (let* ((*OS* (det-*OS*))
         (*path-sep* (det-*path-sep*))
         (qual-argv (process-argv argv))
         (fixed-argv (ecase (car qual-argv)
                       (:script (rest argv))
                       (:binary argv))))
    (clingon:run (cli-main-cmd (nth 1 qual-argv)) fixed-argv)))

;;; vim: set ft=lisp lisp:
