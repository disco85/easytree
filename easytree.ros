#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp(ql:quickload '(clingon cl-ppcre) :silent t)
  )

(defpackage :ros.script.easytree.3962885522
  (:use :cl))
(in-package :ros.script.easytree.3962885522)


(defun truly (x)
  "Like Python's bool()"
  (if x t nil))


;; (defun tree-line-p1 (line)
;;   "Detects that the line looks as a line from `tree` like output"
;;   (let ((i 0) (non-alphanums 0) (path-chars 0) (last-i (1- (length line))))
;;     (and
;;      (char/= #\: (char line last-i))
;;      (loop :for ch = (char line i)
;;            :while (< i last-i)
;;            :while (not (alphanumericp ch))
;;            :do (incf non-alphanums) (incf i)
;;            :finally (return (/= non-alphanums 0)))
;;      (loop :for ch = (char line i)
;;            :while (< i last-i)
;;            ;; can be "+-- non-alpha-num\ #\ copy_(1)"
;;            :while (or (char= #\: ch) (char= #\/ ch) (char= #\\ ch) (alphanumericp ch))
;;            :do (incf path-chars) (incf i)
;;            :finally (return (/= path-chars 0))))))

;; XXX "Permission denied" containing lines must be ignored!
;; XXX Also "cannot open directory"
;; Also tree can print attributes of files
;; Also I should learn (while I detect) where file starts:
;; +-----file
;; +-----  file  <- all lines will start with the same spacing policy


(defun tree-line-det (line)
  "Detects that the line looks as a line from `tree`-like output. Returns
  NIL (not `tree`-like line) or '((:spaces . <spaces-num-before-file-after-decoration>))"
  (let ((i 0) (non-alphanums 0) (spaces 0) (last-i (1- (length line))))
    (when
        (and (> last-i 0)
             (char/= #\: (char line last-i))
             (loop :for ch = (char line i)
                   :while (< i last-i)
                   :while (not (or (alphanumericp ch) (char= ch #\/) (char= ch #\.)))
                   :do (incf non-alphanums) (incf i)
                   :finally (return (/= non-alphanums 0)))
             (loop :for j :downfrom (1- i) :to 0
                   :for ch = (char line j)
                   :while (char= ch #\Space)
                   :do (incf spaces)
                   :finally (return t))
             ;; if after prev. segments there are 1+ alphanums - OK:
             (find-if #'alphanumericp line :start non-alphanums))
      (list (cons :spaces spaces)))))


(defun find-line-det (line)
  "Detects that the line looks as a line from `find`-like output"
  (let ((last-i (1- (length line))))
    (and (> last-i 0)
         (char/= #\: (char line last-i))
         (or (find (char line 0) "./")
             ;; Windows case for busybox (C:\...):
             (and (> last-i 1) (alpha-char-p (char line 0))
                  (char= #\: (char line 1)))))))



(defparameter *unicode-whitespace-chars*
  '(#\Space #\Tab #\Newline #\Return
    #\No-break_space           ; U+00A0
    #\Ogham_space_mark         ; U+1680
    #\En_quad                  ; U+2000
    #\Em_quad                  ; U+2001
    #\En_space                 ; U+2002
    #\Em_space                 ; U+2003
    #\Three-per-em_space       ; U+2004
    #\Four-per-em_space        ; U+2005
    #\Six-per-em_space         ; U+2006
    #\Figure_space             ; U+2007
    #\Punctuation_space        ; U+2008
    #\Thin_space               ; U+2009
    #\Hair_space               ; U+200A
    #\Zero_width_space         ; U+200B
    #\Narrow_no-break_space    ; U+202F
    #\Medium_mathematical_space; U+205F
    #\Ideographic_space))      ; U+3000


(defun trim-any-whitespaces (string)
  "Like Python's str.strip()"
  (string-trim *unicode-whitespace-chars* string))


(defun ls-1r-line-det (line)  ;; XXX Must be ran after `ls-1rl-line-det`
  (let ((last-i (1- (length line))))
    (or (string= "" (trim-any-whitespaces line))
        (and (> last-i 0)
             (find (char line 0) "./" :test #'char=)
             (char= #\: (char line last-i)))
        (and (> last-i 0)
             (not (find (char line 0) *unicode-whitespace-chars* :test #'char=))
             (char/= #\: (char line last-i))))))

(defun ls-1rl-line-det (line)
  ;; TODO
  )
#|
1. tree: starts with non-alphanum symbols (and ' ') longer than 1 - then, only
alphanum symbols and '/' or '\' or ':' (OS depending)

2. find: no NL, no ':' at the end of lines

3. ls -1R: NL, some lines have ':' at the end (but the next line after it - has not ':' at the end)

4. ls -1Rl: the same as 3rd but with additional columns in the front of lines without ':' at the end.
Also it has (after ':'-lines) line as "total 12" (entries). The 1st field of lines-entries may start
with '-' (even more, like -rwx------ or --w-------)
|#


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defparameter *OS* nil)

(defun det-*OS* ()
  (cond ((member :windows *features*) :windows)
        ((member :unix *features*)
         (cond ((member :darwin *features*) :mac)
               (t :unix)))
        (t (error "OS not recognized!"))))


;; Path separator (as a string)
(defparameter *path-sep* nil)

(defun det-*path-sep* ()
  (ecase *OS* (:windows "\\") (:unix "/") (:mac "/")))


;; Known dir listing formats
(defconstant +fmt+ '(:ls :find :tree))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Logic ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun detect-series (input classifiers)
  (let ((results nil)
        ;; current-result is (class-of-series . the-length-of-series):
        (current-result (cons -1 0))
        ;; objects in input that cannot be classified (index in classifiers), will be
        ;; marked with index out of bounds, ie, max allowed index + 1 (or their length):
        (unknown-class (length classifiers))
        ;; did we classified the object using all classifiers on the loop:
        (classified nil))
    (unless (or (null input) (null classifiers))  ;; just ignore empty input/classifiers
      (dolist (obj input)
        (setf classified nil)
        (dotimes (c (length classifiers))
          (when (funcall (nth c classifiers) obj)
            ;; classified by the current classifier or a new one, anyway, must be marked
            ;; as classified, else it will be marked as unknown class:
            (setf classified t)
            (if (= c (car current-result))
                (setf (cdr current-result) (1+ (cdr current-result)))
                (progn
                  (unless (= -1 (car current-result))
                    (push current-result results))
                  (setf current-result (cons c 1))))))
        (unless classified
          ;; if no classifiers recognized obj, then it will be unknown-class. But first,
          ;; we look if the current-result already is unknown-class - if yes, then we
          ;; expand it (increment its length). If it was some known classifier, we add
          ;; it to all results. Else - just replace it (such class is -1):
          (cond
            ((= -1 (car current-result))
             (setf current-result (cons unknown-class 1)))
            ((= unknown-class (car current-result))
             (setf (cdr current-result) (1+ (cdr current-result))))
            (t (push current-result results)
               (setf current-result (cons unknown-class 1)))))))
    ;; the last series, not added by new one, bcs no more iterations - chars ended:
    (unless (= -1 (car current-result))
      (push current-result results))
    (nreverse results)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Command line ;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun cli-convert-cmd-handler (cmd)
  (declare (ignorable cmd)))

(defun cli-convert-cmd-opts ()
  (list
   (clingon:make-option
    :choice
    :description "Input format (from)"
    :short-name #\f
    :long-name "from"
    :key :from
    :items +fmt+)
   (clingon:make-option
    :choice
    :description "Output format (to)"
    :short-name #\t
    :long-name "to"
    :key :to
    :items +fmt+)
   (clingon:make-option
    :string
    :description "Strip paths by prefix (N dirs, string dir)"
    :short-name #\s
    :long-name "strip"
    :key :strip)
   (clingon:make-option
    :string
    :description "Prepend paths with common directory-prefix"
    :short-name #\p
    :long-name "prepend"
    :key :prepend)))

(defun cli-convert-cmd ()
  (clingon:make-command
   :name "convert"
   :usage "[-f FMT] -t FMT [-s N,DIR] [-p DIR]" ;; --strip DIR/<int> --rebase DIR
   :examples '(("Convert from one format to another:" . "ls|convert -f LS -t TREE -")
               ("Convert from unknown format to another:" . "tree|convert -t TREE -")
               ("Convert from unknown format to another:" . "tree|convert -f AUTO -t FIND -"))
   :description "Convert a tree from one format to another one"
   :handler #'cli-convert-cmd-handler
   :options (cli-convert-cmd-opts)))


(defun cli-main-cmd (argv0)
  (declare (ignorable argv0))
  (clingon:make-command
   :name "tree"
   :description "File system tree"
   :version "0.1.0"
   :authors '("John Doe <john.doe@example.org>")
   :license "BSD 2-Clause"
   :sub-commands (list (cli-convert-cmd))
   :handler (lambda (cmd)
              (format t "No known subcommand provided!~%~%")
              (clingon:print-usage cmd *standard-output*)
              (uiop:quit 1))))


;; convert -f AUTO|FIND|LS|TREE -t FIND|LS|TREE
;; union|intersect|diff|uniq -f AUTO|FIND|LS|TREE -f AUTO|FIND|LS|TREE
;; over -f AUTO|FIND|LS|TREE -t FIND|LS|TREE -c <CMD>|ENSURE|DELETE

(defun full-argv ()
  (or
   #+sbcl sb-ext:*posix-argv*
   #+clisp ext:*args*
   #+cmu extensions:*command-line-words*
   #+allegro (sys:command-line-arguments)
   #+lispworks system:*line-arguments-list*
   nil))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Main ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun process-argv (argv)
  (let* ((fargv (full-argv))
         (buf (make-string 3))
         (arg0-file-header (handler-case ;; if we cannot read, return fake 3 item string
                            (with-open-file (strm (car argv) :direction :input)
                              (and (read-sequence buf strm) buf))
                             (error () (make-string 3)))))
    (cond ((string= "#!/" (subseq arg0-file-header 0 3)) (list :script (car argv)))
          (t (list :binary (car fargv))))))


(defun main (&rest argv)
  (let* ((*OS* (det-*OS*))
         (*path-sep* (det-*path-sep*))
         (qual-argv (process-argv argv))
         (fixed-argv (ecase (car qual-argv)
                       (:script (rest argv))
                       (:binary argv))))
    (clingon:run (cli-main-cmd (nth 1 qual-argv)) fixed-argv)))

;;; vim: set ft=lisp lisp:
