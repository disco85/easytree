#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp(ql:quickload '(clingon cl-ppcre sijo-doctest uiop) :silent t)
  )

(defpackage :ros.script.easytree.3962885522
  (:use :cl))
(in-package :ros.script.easytree.3962885522)


(defun dbg (s x) (format t "*** TRACE[~A]: ~S~% ***" s x) x)



(defstruct <scanner-state> ;;(:conc-name <scanner-state>-))
  "The state of the scanner, it can be saved then rejected (for backtracking)"
  (pos 0 :type (integer 0 *))
  result
  (id "" :type string))

(defclass <scanner> ()
    ((pos
      :initform 0
      :accessor <scanner>-pos
      :documentation "Cursor")
     (saved-states
      :initform nil
      :accessor <scanner>-saved-states
      :documentation "Stack of saved positions and intermediate results, pop allows backtracking")))

(defun pop-items (items &key after-item within-item key test)
  "Pops items after-item chosen one including it `:within-item item` or without
it `:after-item item`. Finding of the item use :test or/and :key criteria
like standard member/find functions do it. If the item cannot be found,
`items` are returned. The second returned value is NIL then. Else,
`items` without poped items are returned. The second value is T,
check it with:

>> (multiple-value-list (pop-items '(1 2 3) :after-item 2 :test #'=))
'((2 3) t)
>> (multiple-value-list (pop-items '(1 2 3) :within-item 2 :test #'=))
'((3) t)
>> (multiple-value-list (pop-items '(1 2 3) :within-item 20 :test #'=))
'((1 2 3) nil)
>> (multiple-value-list (pop-items '(1 2 3) :within-item 3 :test #'=))
'(nil t)
"
  (let* ((pivot-item (or after-item within-item))
         (member-extra-args (append (when key  (list :key key))
                                    (when test (list :test test))))
         (remains  ;; [1 2 3] 4 5  <- pop-ed are in the head. Push - to the head too
           (apply #'member pivot-item items member-extra-args)))
    (cond
      ((null remains) (values items nil))
      (after-item (values remains t))
      (within-item (values (cdr remains) t)))))

(defmethod save-state ((scanner <scanner>) (state <scanner-state>))
  "Saves/pushs a state in a scanner"
  (push state (<scanner>-saved-states scanner)))

;; FIXME reuse thid method in another methods
(defmethod restore-states ((scanner <scanner>) (to-state <scanner-state>)
                           &key before-the-state)
  (let ((pop-items-extra-args (if before-the-state
                                  (list :within-item to-state :test #'eq)
                                  (list :after-item to-state :test #'eq))))
    (multiple-value-bind
          (new-states states-were-changed) (apply #'pop-items
                                                  (<scanner>-saved-states scanner)
                                                  pop-items-extra-args)
      (when states-were-changed
        (if new-states
          (progn
            (setf (<scanner>-saved-states scanner) new-states)
            (setf (<scanner>-pos scanner) (<scanner-state>-pos (car new-states))))
          (progn
            (setf (<scanner>-saved-states scanner) nil) ;; new-state is nil but anyway :)
            (setf (<scanner>-pos scanner) 0)))))))

(defmethod restore-states ((scanner <scanner>) (to-state string)
                           &key before-the-state)
  (let ((found-state (find to-state (<scanner>-saved-states scanner)
                           :key #'<scanner-state>-id
                           :test #'string=)))
    (when found-state
      (restore-states scanner found-state :key before-the-state))))

(defmethod restore-states ((scanner <scanner>) (to-state null)
                           &key before-the-state)
  (let ((last-state (pop (<scanner>-saved-states scanner))))
    (when last-state (restore-states scanner last-state :key before-the-state))))


;; (defun truly (x)
;;   "Like Python's bool()"
;;   (if x t nil))

(defun implies (a b)
  "Implication: a -> b"
  (or (not a) b))


(defun starts-with-p (string prefix &key case-insensitive)
  "Check that `string` starts with `prefix`"
  (and (<= (length prefix) (length string))
       (if case-insensitive
           (string-equal prefix (subseq string 0 (length prefix)))
           (string= prefix (subseq string 0 (length prefix)) :start1 0 :start2 0))))


(defun ch-at (string i)
  (if (or (>= i (length string)) (< i 0)) nil (char string i)))

;; XXX "Permission denied" containing lines must be ignored!
;; XXX Also "cannot open directory"
;; Also tree can print attributes of files
;; Also I should learn (while I detect) where file starts:
;; +-----file
;; +-----  file  <- all lines will start with the same spacing policy

;; TODO *-det must match only unique features, so `find .` will not be recognized as
;; ls. But what should match "/aaa/bbb:" then? ls -1Rl or ls -1R ?

(defun tree-line-det (line)
  "Detects that the line looks as a line from `tree`-like output. Returns
  NIL (not `tree`-like line) or '((:spaces . <spaces-num-before-file-after-decoration>))"
  (let ((i 0) (non-alphanums 0) (spaces 0) (last-i (1- (length line))))
    (when
        (and (> last-i 0)
             (char/= #\: (ch-at line last-i))
             (loop :for ch = (ch-at line i)
                   :while (< i last-i)
                   :while (not (or (alphanumericp ch) (char= ch #\/) (char= ch #\.)
                                   (char= ch #\') (char= ch #\")))
                   :do (incf non-alphanums) (incf i)
                   :finally (return (/= non-alphanums 0)))
             (loop :for j :downfrom (1- i) :to 0
                   :for ch = (ch-at line j)
                   :while (char= ch #\Space)
                   :do (incf spaces)
                   :finally (return t))
             ;; if after prev. segments there are 1+ alphanums - OK:
             (find-if #'alphanumericp line :start non-alphanums))
      (list (cons :spaces spaces)))))


(defun find-line-det (line)
  "Detects that the line looks as a line from `find`-like output"
  (let ((last-i (1- (length line))))
    (when
        (and (> last-i 0)
             (char/= #\: (ch-at line last-i))
             (or (starts-with-p line "/")
                 (starts-with-p line "./")
                 (starts-with-p line "../")
                 (starts-with-p line "'./")
                 (starts-with-p line "\"./")
                 (starts-with-p line "'../")
                 (starts-with-p line "\"../")))
      (list (cons :uniq-features 1)))))


(defparameter *unicode-whitespace-chars*
  '(#\Space #\Tab #\Newline #\Return
    #\No-break_space           ; U+00A0
    #\Ogham_space_mark         ; U+1680
    #\En_quad                  ; U+2000
    #\Em_quad                  ; U+2001
    #\En_space                 ; U+2002
    #\Em_space                 ; U+2003
    #\Three-per-em_space       ; U+2004
    #\Four-per-em_space        ; U+2005
    #\Six-per-em_space         ; U+2006
    #\Figure_space             ; U+2007
    #\Punctuation_space        ; U+2008
    #\Thin_space               ; U+2009
    #\Hair_space               ; U+200A
    #\Zero_width_space         ; U+200B
    #\Narrow_no-break_space    ; U+202F
    #\Medium_mathematical_space; U+205F
    #\Ideographic_space))      ; U+3000


(defun trim-any-whitespaces (string)
  "Like Python's str.strip()"
  (string-trim *unicode-whitespace-chars* string))

;; TODO ../ in the beginning is also possible!!!
;; ending can be @, =, etc...

(defun ls-1r-line-det (line)  ;; XXX Must be ran after `ls-1rl-line-det`
  (let ((last-i (1- (length line)))
        (uniq-features 0))
    (when
        (or
         (when (string= "" (trim-any-whitespaces line)) (incf uniq-features))
         (and (> last-i 0)
              ;; If there are spaces, the line must start with ' or " (else: not our case, T)
              (implies (find #\Space line :test #'char=) (case (ch-at line 0) (#\' t) (#\" t)))
              (case (ch-at line 0)
                ((#\' #\" #\/ #\.) t)
                (t (alphanumericp (ch-at line 0))))
              (or (and (char= #\: (ch-at line last-i))
                       (or (starts-with-p line "/")
                           (starts-with-p line "./")
                           (starts-with-p line "../")
                           (starts-with-p line "'./")
                           (starts-with-p line "\"./")
                           (starts-with-p line "'../")
                           (starts-with-p line "\"../")))
                  ;; TODO windows?
                  (char/= #\: (ch-at line last-i)))))
      (list (cons :uniq-features uniq-features)))))


(defun ls-1rl-line-det (line)
  (let* ((last-i (1- (length line)))
         (total-str "total ")
         (file-delim (case (ch-at line last-i)
                       (#\' #\')
                       (#\" #\")
                       (t #\Space)))
         (attrs 0) (i 0) (filechars 0) (mtimechars 0)
         (uniq-features 0))
    (when
        (and (> last-i 0)
             ;; TODO windows?
             (or (and (starts-with-p line total-str) (> last-i (length total-str))
                      (digit-char-p (ch-at line (length total-str))))
                 (and (char= #\: (ch-at line last-i))
                      (or (starts-with-p line "/")
                          (starts-with-p line "./")
                          (starts-with-p line "../")
                          (starts-with-p line "'./")
                          (starts-with-p line "\"./")
                          (starts-with-p line "'../")
                          (starts-with-p line "\"../")))
                 (when
                     (and
                      ;; 17 - minimum length with minimal column sizes and 1 space-delimiter:
                      (>= last-i 17)
                      (loop :for ch = (ch-at line i)
                            :while (< i last-i)
                            :while (or (char= ch #\-) (char= ch #\r) (char= ch #\w) (char= ch #\x)
                                       (char= ch #\l) (char= ch #\b) (char= ch #\c) (char= ch #\p)
                                       (char= ch #\s) (char= ch #\D) (char= ch #\P) (char= ch #\n)
                                       (char= ch #\C) (char= ch #\M) (char= ch #\?) (char= ch #\S)
                                       (char= ch #\t) (char= ch #\T) (char= ch #\d)
                                       (char= ch #\+) (char= ch #\.) (char= ch #\@))
                            :while (char/= ch #\Space)
                            :do (incf attrs) (incf i)
                            :finally (return (or (= attrs 10) (= attrs 11))))
                      (char= (ch-at line i) #\Space)
                      (loop :for j :downfrom last-i :to 0
                            :for ch = (ch-at line j)
                            :while (or (char/= ch file-delim) (= j last-i))
                            :do (incf filechars)
                            :finally
                               (when
                                   ;; Files with spaces or '/" are quoted with "...'..." and
                                   ;; '..."...'. If file is not quoted, when we hit the space,
                                   ;; we counted file size correctly. But when we hit '/", we
                                   ;; counted the rightmost '/" and all file symbols, but not
                                   ;; the leftmost '/", to do it, we have to do yet another
                                   ;; iteration! So, when the exit-char hit by us is not space,
                                   ;; it is some quote-symbol, so increment filechars to treat
                                   ;; 'xxx' as 5 symbols, not 4
                                   (char/= ch #\Space) (incf filechars))
                               ;; (format t "'~A' (~C)~%" filechars file-delim)
                               (return (> filechars 0)))
                      (loop :for j :downfrom (- last-i filechars 1) :to 0
                            :for ch = (ch-at line j)
                            :while (or (digit-char-p ch) (char= ch #\:))
                            :do (incf mtimechars) ;; last column of mtime is HH:MM or YYYY
                            :finally (return (or (= mtimechars 4) (= mtimechars 5)))))
                   (incf uniq-features 1))))
      (list (cons :uniq-features uniq-features)))))


(defun safe-assoc (pairs kw &key default)
  (let ((p (and (listp pairs)
                (assoc kw (remove-if-not #'consp pairs)))))
    (if p (cdr p) default)))


(defun get-uniq-features (det-result &optional default)
  "Returns :uniq-features from a determination result, which usually is
  NIL or '((:uniq-features) <int>)...) or something else. If it cannot
  be got, then it returns `default` (NIL or passed)''"
  (safe-assoc det-result :uniq-features :default default))


(defun det-format (funcs lines)
  "Finds the function (among `funcs`, returned as an index) which is mostly satisfied
  on `lines` (at least once! Else - returns nil)"
  (let* ((aggregate-func-lines-results
           (lambda (acc e)
             (if e
                 (list (1+ (car acc)) (+ (get-uniq-features e 0) (cadr acc)))
                 acc)))
         (funcs-over-lines-results (mapcar (lambda (fn) (mapcar fn lines)) funcs))
         (funcs-results-0 (mapcar (lambda (lines-results)
                                    (reduce aggregate-func-lines-results
                                            lines-results
                                            :initial-value (list 0 0)))
                                  funcs-over-lines-results))
         ;; just enumerated (0 ...) (1 ...)... :
         (funcs-results-1 (loop :for e :in funcs-results-0
                                :for i :from 0
                                :collect (cons i e)))
         (sorted-by-hits (sort funcs-results-1
                               (lambda (a b)
                                 (or (> (car a) (car b))
                                     (and (= (car a) (car b))
                                          (> (cadr a) (cadr b)))))
                               :key #'cdr)))
    (and funcs lines (caar sorted-by-hits))))


  ;; (let* ((funcs-hits (mapcar (lambda (fn)
  ;;                              (count-if fn lines))
  ;;                            funcs))
  ;;        (max-hits-num (apply #'max funcs-hits)))
  ;;   (and (> max-hits-num 0)
  ;;        (position max-hits-num funcs-hits))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defparameter *OS* nil)

(defun det-*OS* ()
  (cond ((member :windows *features*) :windows)
        ((member :unix *features*)
         (cond ((member :darwin *features*) :mac)
               (t :unix)))
        (t (error "OS not recognized!"))))


;; Path separator (as a string)
(defparameter *path-sep* nil)

(defun det-*path-sep* ()
  (ecase *OS* (:windows "\\") (:unix "/") (:mac "/")))


;; Known dir listing formats
(defconstant +fmt+ '(:ls :find :tree))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Logic ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun detect-series (input classifiers)
  (let ((results nil)
        ;; current-result is (class-of-series . the-length-of-series):
        (current-result (cons -1 0))
        ;; objects in input that cannot be classified (index in classifiers), will be
        ;; marked with index out of bounds, ie, max allowed index + 1 (or their length):
        (unknown-class (length classifiers))
        ;; did we classified the object using all classifiers on the loop:
        (classified nil))
    (unless (or (null input) (null classifiers))  ;; just ignore empty input/classifiers
      (dolist (obj input)
        (setf classified nil)
        (dotimes (c (length classifiers))
          (when (funcall (nth c classifiers) obj)
            ;; classified by the current classifier or a new one, anyway, must be marked
            ;; as classified, else it will be marked as unknown class:
            (setf classified t)
            (if (= c (car current-result))
                (setf (cdr current-result) (1+ (cdr current-result)))
                (progn
                  (unless (= -1 (car current-result))
                    (push current-result results))
                  (setf current-result (cons c 1))))))
        (unless classified
          ;; if no classifiers recognized obj, then it will be unknown-class. But first,
          ;; we look if the current-result already is unknown-class - if yes, then we
          ;; expand it (increment its length). If it was some known classifier, we add
          ;; it to all results. Else - just replace it (such class is -1):
          (cond
            ((= -1 (car current-result))
             (setf current-result (cons unknown-class 1)))
            ((= unknown-class (car current-result))
             (setf (cdr current-result) (1+ (cdr current-result))))
            (t (push current-result results)
               (setf current-result (cons unknown-class 1)))))))
    ;; the last series, not added by new one, bcs no more iterations - chars ended:
    (unless (= -1 (car current-result))
      (push current-result results))
    (nreverse results)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Command line ;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun cli-tests-handler (cmd)
  (declare (ignorable cmd))
  (multiple-value-bind (failed passed)
      (sijo-doctest:test-package :ros.script.easytree.3962885522)
    (format t "~&~A failed, ~A passed~%" failed passed)
    (when (> failed 0)
      (uiop:quit 1))))

  ;; (sijo-doctest:test :ros.script.easytree.3962885522))

(defun cli-convert-cmd-handler (cmd)
  (declare (ignorable cmd)))

(defun cli-convert-cmd-opts ()
  (list
   (clingon:make-option
    :choice
    :description "Input format (from)"
    :short-name #\f
    :long-name "from"
    :key :from
    :items +fmt+)
   (clingon:make-option
    :choice
    :description "Output format (to)"
    :short-name #\t
    :long-name "to"
    :key :to
    :items +fmt+)
   (clingon:make-option
    :string
    :description "Strip paths by prefix (N dirs, string dir)"
    :short-name #\s
    :long-name "strip"
    :key :strip)
   (clingon:make-option
    :string
    :description "Prepend paths with common directory-prefix"
    :short-name #\p
    :long-name "prepend"
    :key :prepend)))

(defun cli-tests-cmd ()
  (clingon:make-command
   :name "tests"
   :usage "<no args>"
   :description "Run tests"
   :handler #'cli-tests-handler))

(defun cli-convert-cmd ()
  (clingon:make-command
   :name "convert"
   :usage "[-f FMT] -t FMT [-s N,DIR] [-p DIR]" ;; --strip DIR/<int> --rebase DIR
   :examples '(("Convert from one format to another:" . "ls|convert -f LS -t TREE -")
               ("Convert from unknown format to another:" . "tree|convert -t TREE -")
               ("Convert from unknown format to another:" . "tree|convert -f AUTO -t FIND -"))
   :description "Convert a tree from one format to another one"
   :handler #'cli-convert-cmd-handler
   :options (cli-convert-cmd-opts)))


(defun cli-main-cmd (argv0)
  (declare (ignorable argv0))
  (clingon:make-command
   :name "tree"
   :description "File system tree"
   :version "0.1.0"
   :authors '("John Doe <john.doe@example.org>")
   :license "BSD 2-Clause"
   :sub-commands (list (cli-convert-cmd) (cli-tests-cmd))
   :handler (lambda (cmd)
              (format t "No known subcommand provided!~%~%")
              (clingon:print-usage cmd *standard-output*)
              (uiop:quit 1))))


;; convert -f AUTO|FIND|LS|TREE -t FIND|LS|TREE
;; union|intersect|diff|uniq -f AUTO|FIND|LS|TREE -f AUTO|FIND|LS|TREE
;; over -f AUTO|FIND|LS|TREE -t FIND|LS|TREE -c <CMD>|ENSURE|DELETE

(defun full-argv ()
  (or
   #+sbcl sb-ext:*posix-argv*
   #+clisp ext:*args*
   #+cmu extensions:*command-line-words*
   #+allegro (sys:command-line-arguments)
   #+lispworks system:*line-arguments-list*
   nil))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Main ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun process-argv (argv)
  (let* ((fargv (full-argv))
         (buf (make-string 3))
         (arg0-file-header (handler-case ;; if we cannot read, return fake 3 item string
                            (with-open-file (strm (car argv) :direction :input)
                              (and (read-sequence buf strm) buf))
                             (error () (make-string 3)))))
    (cond ((string= "#!/" (subseq arg0-file-header 0 3)) (list :script (car argv)))
          (t (list :binary (car fargv))))))


(defun main (&rest argv)
  (let* ((*OS* (det-*OS*))
         (*path-sep* (det-*path-sep*))
         (qual-argv (process-argv argv))
         (fixed-argv (ecase (car qual-argv)
                       (:script (rest argv))
                       (:binary argv))))
    (clingon:run (cli-main-cmd (nth 1 qual-argv)) fixed-argv)))

;;; vim: set ft=lisp lisp:
