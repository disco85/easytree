#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp(ql:quickload '(clingon cl-ppcre fiveam uiop) :silent t)
  )

(defpackage :ros.script.easytree
  (:use :cl))
(in-package :ros.script.easytree)


(defvar *dbg-cond* nil)
(defun dbg (s &optional (x nil) &key (cond nil)) (when (or *dbg-cond* cond) (format t "~%*** TRACE[~A]: ~S~% ***~%" s x)) x)


(defun implies (a b)
  "Implication: a -> b"
  (or (not a) b))


(defun starts-with-p (STRING PREFIX &key CASE-INSENSITIVE)
  "Check that `string` starts with `PREFIX`"
  (let ((string-len (length STRING)) (prefix-len (length PREFIX)))
    (and (<= prefix-len string-len)
         (if CASE-INSENSITIVE
             (string-equal PREFIX (subseq STRING 0 prefix-len))
             (string= PREFIX (subseq STRING 0 prefix-len))))))

(defun ends-with-p (STRING SUFFIX &key CASE-INSENSITIVE)
  "Check that `string` ends with `SUFFIX`"
  (let ((string-len (length STRING)) (suffix-len (length SUFFIX)))
    (and (<= suffix-len string-len)
         (if CASE-INSENSITIVE
             (string-equal SUFFIX (subseq STRING (- string-len suffix-len)))
             (string= SUFFIX (subseq STRING (- string-len suffix-len)))))))


(defun ch-at (STRING I &key (only-positive nil))
  (let ((len (length STRING)))
    (cond
      ((null I) nil)
      ((or (< I (- len)) (>= I len)) nil)
      ((< I 0) (if only-positive nil
                   (char STRING (+ len I))))
      (t (char STRING I)))))


(defun emptyp (x)
  (or (null x) (and (stringp x) (string= "" x))))

(defun unquote-str (STR)  ;; TODO not needed - another logic should be used
  "Unquotes string quoted in ' and \" (if a string is quoted, else returns it as is)"
  (cond ((or (and (starts-with-p STR "'") (ends-with-p STR "'"))
             (and (starts-with-p STR "\"") (ends-with-p STR "\"")))
         (subseq STR 1 (1- (length STR))))
        (t STR)))

;; (defun reverse-string-in-place (s)
;;   (let ((len (length s)))
;;     (dotimes (i (floor len 2) s)
;;       (rotatef (aref s i)
;;                (aref s (- len i 1))))))

;; Special characters for Unix shells requiring escaping when THEY ARE INSIDE "LS" COMMAND OUTPUT
;; (so, no '.' among them):
(defconstant +shell-special-characters+ "\\'`\"/!@#$%^&*()-_+={}[]|;:,<>? '}") ;; TODO check them in ls !
(defconstant +shell-string-special-characters+ "\"\\$`")

(declaim (ftype (function (string) cons) extract-ls-fname))
(defun extract-ls-fname (STR)
  "Extracts file name/path from `ls` shell command output looking for it at the end of
a line (so it supports `ls -l..` and `ls ...`). It supports single/double quoting,
escaping of special characters inside double quoting and in shell (no quoting inside
signle quotes). In general, shell paths look:
<inside-shell>'<inside-single-quoting>'\"<inside-double-quoting>\"
"
  ;; See about escaping: https://stackoverflow.com/questions/15783701/which-characters-need-to-be-escaped-when-using-bash
  (let ((pos (length STR))
        (ch nil)
        (spec-ch nil)
        (is-shell-special-ch nil)
        (is-str-special-ch nil)
        (fail-msg nil)
        (mark 0)
        (fname nil))
    (labels ((prev-ch ()
               ;; reads previous char (we traverse from the end of STR to the beginning)
               (if (<= pos 0)
                   (setf ch :eof)
                   (progn
                     (setf ch (or (ch-at STR (decf pos)) :eof))
                     (setf is-shell-special-ch (find ch +shell-special-characters+))
                     (setf is-str-special-ch (find ch +shell-string-special-characters+))))
               ch)
             (back-ch ()
               ;; returns char back to the next read
               (incf pos))
             (mark-pos ()
               ;; remember particular position which can be the start of fail
               (setf mark (1+ pos))))
      (setf fname (with-output-to-string (res)
                    (tagbody
                     in-shell ;;;;;;;;;;;;;;;;;;;;;; IN SHELL ;;;;;;;;;;;;;;;;;;;;;;;
                       (case (prev-ch)
                         (#\"
                          (mark-pos)
                          (case (prev-ch)
                            (#\\
                             (write-char #\" res)
                             (go in-shell))
                            (:eof
                             (setf fail-msg (format nil "unclosed \" on ~A" mark))
                             (go end))
                            (t
                             (back-ch)
                             (go in-double-quotes))))
                         (#\'
                          (mark-pos)
                          (case (prev-ch)
                            (#\\
                             (write-char #\' res)
                             (go in-shell))
                            (:eof
                             (setf fail-msg (format nil "unclosed ' on ~A" mark))
                             (go end))
                            (t
                             (back-ch)
                             (go in-single-quotes))))
                         (:eof
                          (go end))
                         (#\Space
                          (case (prev-ch)
                            (#\\
                             (write-char #\Space res)
                             (go in-shell))
                            (:eof
                             (go end))
                            (t
                             (go end))))
                         (t
                          (if is-shell-special-ch
                              (progn (mark-pos)
                                     (setf spec-ch ch)
                                     (case (prev-ch)
                                       (#\\
                                        (write-char spec-ch res)
                                        (go in-shell))
                                       (:eof
                                        (setf fail-msg
                                              (format nil "EOF while unescaped shell special character '~A' on ~A" spec-ch mark))
                                        (go end))
                                       (t
                                        (setf fail-msg
                                              (format nil "unescaped shell special character '~A' on ~A" spec-ch mark))
                                        (go end))))
                              (progn (write-char ch res)
                                     (go in-shell)))))
                     in-single-quotes  ;;;;;;;;;;;;;;;;;;; IN SINGLE QUOTE ;;;;;;;;;;;;;;;;;;;;;
                       (case (prev-ch)
                         (#\'
                          (go in-shell))
                         (:eof
                          (setf fail-msg (format nil "unclosed ' on ~A" mark))
                          (go end))
                         (t
                          (write-char ch res)
                          (go in-single-quotes)))
                     in-double-quotes  ;;;;;;;;;;;;;;;;;;;; IN DOUBLE QUOTE ;;;;;;;;;;;;;;;;;;;;;;;;;
                       (case (prev-ch)
                         (:eof
                          (setf fail-msg (format nil "unclosed \" on ~A" mark))
                          (go end))
                         (#\"
                          (case (prev-ch)
                            (#\\
                             (write-char ch res)
                             (go in-double-quotes))
                            (:eof
                             (go in-shell))
                            (t
                             (back-ch)
                             (go in-shell))))
                         (t
                          (if is-str-special-ch
                              (progn
                                (mark-pos)
                                (setf spec-ch ch)
                                (case (prev-ch)
                                  (#\\
                                   (write-char spec-ch res)
                                   (go in-double-quotes))
                                  (:eof
                                   (setf fail-msg
                                         (format nil "EOF while unescaped string special character '~A' on ~A" spec-ch mark))
                                   (go end))
                                  (t
                                   (setf fail-msg
                                         (format nil "unescaped string special character '~A' on ~A" spec-ch mark))
                                   (go end))))
                              (progn
                                (write-char ch res)
                                (go in-double-quotes)))))
                     end)))
      (cond
        (fail-msg `(fail . ,fail-msg))
        ((emptyp fname) '(fail . "empty path"))
        (t `(fname . ,(reverse fname))))
      ;; (if fail-msg
      ;;     (cons 'fail fail-msg)
      ;;     (cons 'fname (reverse fname)))
      )))

(deftype <fsobj> () '(member :file :dir))

(defconstant +formats+ '(:tree :find :ls1r :ls1rl))
(deftype <format> ()
  `(member nil ,@ +formats+))

(defun other-formats (FORMAT)
  "Returns all +formats+ except FORMAT"
  (remove-if (lambda (fmt) (eq fmt FORMAT)) +formats+))

(defstruct <parsed-line>
  (format nil :type (or null <format>))
  (fname "" :type string)
  (fmode 0 :type integer)
  (fsobj :file :type <fsobj>))

(defstruct <tree-state>
  ;; Stack of indents in a tree directory representation,it is not 1,2,3, but any integers.
  ;; It's a list, not just one integer, bcs we can decrease depth from 30 to 12 and, if it
  ;; is an integer, we cannot know how many dirs we exited: one 30->12, two 30->20->12, ...:
  (indents nil :type (or null list))
  ;; Stack of file/dir names in a tree directory representation:
  (fnames nil :type (or null list)))

(defstruct <ls1r-state>
  ;; Stack of current directories
  (dir nil :type (or null string))
  (fname-hashes (make-hash-table :test 'equal)))

(defstruct (<ls1rl-state> (:include <ls1r-state>)))

(defstruct <parsed-lines>
  ;; (number 0 :type integer)
  (dir-from-final-slash t :type boolean)
  (detected-format nil :type (or null <format>))
  (verbose nil :type boolean)  ;; TODO add it to parse-* funcs
  (tree-fail-msg nil :type (or null string)) ;; last fail message of this format
  (find-fail-msg nil :type (or null string)) ;; last fail message of this format
  (ls1r-fail-msg nil :type (or null string)) ;; last fail message of this format
  (ls1rl-fail-msg nil :type (or null string)) ;; last fail message of this format
  (as-tree nil :type (or null list))  ;; list of <parsed-line>
  (as-find nil :type (or null list))
  (as-ls1r nil :type (or null list))
  (as-ls1rl nil :type (or null list))
  (tree-state (make-<tree-state>) :type <tree-state>)
  (ls1r-state (make-<ls1r-state>) :type <ls1r-state>)
  (ls1rl-state (make-<ls1rl-state>) :type <ls1rl-state>))

(declaim (ftype (function (<parsed-lines> <format>) null) reset-parsed-lines-fails))
(defun reset-parsed-lines-fails (PARSED-LINES FORMAT)
  (ecase FORMAT
    (:tree (setf (<parsed-lines>-tree-fail-msg PARSED-LINES) nil))
    (:find (setf (<parsed-lines>-find-fail-msg PARSED-LINES) nil))
    (:ls1r (setf (<parsed-lines>-ls1r-fail-msg PARSED-LINES) nil))
    (:ls1rl (setf (<parsed-lines>-ls1rl-fail-msg PARSED-LINES) nil))))

(declaim (ftype (function (<parsed-lines> <format>) list) get-parsed-lines))
(defun get-parsed-lines (PARSED-LINES FORMAT)
  (ecase FORMAT
    (:tree (<parsed-lines>-as-tree PARSED-LINES))
    (:find (<parsed-lines>-as-find PARSED-LINES))
    (:ls1r (<parsed-lines>-as-ls1r PARSED-LINES))
    (:ls1rl (<parsed-lines>-as-ls1rl PARSED-LINES))))

(declaim (ftype (function (<parsed-lines> <format>) (or null string)) get-parsed-lines-fail-msg))
(defun get-parsed-lines-fail-msg (PARSED-LINES FORMAT)
  (ecase FORMAT
    (:tree (<parsed-lines>-tree-fail-msg PARSED-LINES))
    (:find (<parsed-lines>-find-fail-msg PARSED-LINES))
    (:ls1r (<parsed-lines>-ls1r-fail-msg PARSED-LINES))
    (:ls1rl (<parsed-lines>-ls1rl-fail-msg PARSED-LINES))))

(defun get-cons-with-longest-list (conses)
  "Returns a list of cons-es with the longest cdr:

CL-USER> (get-cons-with-longest-list '((1 2 3) (2 11 12 13)))
((2 11 12 13))
CL-USER> (get-cons-with-longest-list '((1 2 3) (2 11 12)))
((1 2 3) (2 11 12))
"
  (reduce (lambda (res cons-i)
            (let* ((parsed-lines-i (cdr cons-i))
                   (parsed-lines-i-len (length parsed-lines-i))
                   (parsed-lines-max-len (if res (length (cdar res)) 0)))
              (cond ((null res) (list cons-i))
                    ((> parsed-lines-i-len parsed-lines-max-len)
                     (list cons-i))
                    ((= parsed-lines-i-len parsed-lines-max-len)
                     (append res (list cons-i)))
                    (t res))))
          conses
          :initial-value nil))

(declaim (ftype (function (<parsed-lines>) list) get-most-parsed-lines))
(defun get-most-parsed-lines (PARSED-LINES)
  "Returns a list of the longest lists of accumulated <parsed-line> items
in a form (<format> . lines-list)"
  (get-cons-with-longest-list
   (mapcar (lambda (fmt)
             (cons fmt (get-parsed-lines PARSED-LINES fmt)))
           +formats+)))

(declaim (ftype (function (<parsed-lines> <format> list) list) set-parsed-lines))
(defun set-parsed-lines (PARSED-LINES FORMAT NEW-VALUE)
  (ecase FORMAT
    (:tree (setf (<parsed-lines>-as-tree PARSED-LINES) NEW-VALUE))
    (:find (setf (<parsed-lines>-as-find PARSED-LINES) NEW-VALUE))
    (:ls1r (setf (<parsed-lines>-as-ls1r PARSED-LINES) NEW-VALUE))
    (:ls1rl (setf (<parsed-lines>-as-ls1rl PARSED-LINES) NEW-VALUE))))

;; TODO instead of set-parsed-lines - rplaca/nconc can be used over `lines` in add-to-parsed-lines, modify-last-parsed-line

(declaim (ftype (function (<parsed-lines> <format> <parsed-line>) list) add-to-parsed-lines))
(defun add-to-parsed-lines (PARSED-LINES FORMAT PARSED-LINE)
  "Adds a <parsed-line> to <parsed-lines> FORMAT (relies on a callee that it will
not add it to wrong FORMAT)"
  (let* ((lines (get-parsed-lines PARSED-LINES FORMAT))
         (new-lines (append lines (list PARSED-LINE))))
    ;; (dbg (format nil "!!!!!!!!!add-to-parsed-lines: lines: ~X new-lines: ~X~%" lines new-lines))
    (set-parsed-lines PARSED-LINES FORMAT new-lines)))

(declaim (ftype (function (<parsed-lines> <format> (function (<parsed-line>) <parsed-line>)) list) modify-last-parsed-line))
(defun modify-last-parsed-line (PARSED-LINES FORMAT MOD-FUNC)
  "Modifies a <parsed-line> in <parsed-lines> of a FORMAT by a function MOD-FUNC"
  (let* ((lines (get-parsed-lines PARSED-LINES FORMAT))
         (last-parsed-line (car (last lines)))
         (new-lines (if last-parsed-line
                        (append (butlast lines) (list (funcall MOD-FUNC last-parsed-line)))
                        lines)))
    (set-parsed-lines PARSED-LINES FORMAT new-lines)))

;; (declaim (ftype (function (<parsed-lines> list) (or null list)) add-to-actively-parsed-lines))
;; (defun add-to-actively-parsed-lines (PARSED-LINES RESULTS)
;;   "Puts results, list of cons-es `(<format> . <parsed-line>)`, to <parsed-lines> if it is
;; possible yet (there are yet actively collecting <parsed-line> lists)"
;;   (let* ((already-lines (<parsed-lines>-number PARSED-LINES))
;;          (results-to-add
;;            (remove-if-not
;;             (lambda (result)
;;               (destructuring-bind (fmt parsed-line) result
;;                 (declare (ignore parsed-line))
;;                 (eql already-lines (length (get-parsed-lines PARSED-LINES fmt)))))
;;             RESULTS))
;;          (updated (mapcar (lambda (result)
;;                             (destructuring-bind (fmt parsed-line) result
;;                               (add-to-parsed-lines PARSED-LINES fmt parsed-line)))
;;                           results-to-add)))
;;     updated))

(defun pop-until (stack pred &key include)
  "Pops items from the head of the list (stack) optionally including the found item.
The item is looking for using a predicate function:

CL-USER> (pop-until '(1 2 3 4 5) (lambda (x) (= x 1)) :include t)
(2 3 4 5)
"
  (let* ((pos (position-if pred stack))
         (pos1 (when pos (if include (1+ pos) pos))))
    (when pos (values (subseq stack pos1) pos1))))

(defun eq-to (el &key (test #'equal))
  "Returns a function comparing any value to `el` using a test function (default #'equal).
It can be used together with (pop-until ...)
"
  (lambda (x) (funcall test el x)))


(defun path-parts-to-str (parts &key (part nil) (sep "/"))
  "Converts dir/file parts to a string using optional path separator `sep` and possibly adding the suffix part"
  (if (and (null parts) (null part)) ""
      (reduce (lambda (e1 e2) (concatenate 'string e1 sep e2))
              (if part (append parts (list part)) parts))))

;; This functions can produce duplicates of file entries (bcs input can contain them in a way,
;; when it is not easy to remove duplicates on the phase of parsing). When they will be used
;; to reproduce directories/files - it should be handled (if it exists, not to make it):
(declaim (ftype (function (<parsed-lines> string) (or null <parsed-line>)) parse-line-as-tree))
(declaim (ftype (function (<parsed-lines> string) (or null <parsed-line>)) parse-line-as-find))
(declaim (ftype (function (<parsed-lines> string) (or null <parsed-line>)) parse-line-as-ls1r))
(declaim (ftype (function (<parsed-lines> string) (or null <parsed-line>)) parse-line-as-ls1rl))

;; TODO support /etc (currently I think / will not be collected as fname)
(defun markup-line-as-tree (STR)
  "Marks up STR possibly looking as a line from `tree`-like output. Returns
  NIL (not `tree`-like line) or alist:
'((fname . file-name) (fname-start . index-of-fname) (fname-stop . index-or-NIL))"
  (let ((last-i (1- (length STR))) (i 0) (j 0) (fname ""))
    (when
        (and (>= last-i 0)
             (char/= #\: (ch-at STR last-i)))
      ;; skip chars that are not alphanum (decoration lines, spaces):
      (loop :initially (setf i 0)
            :for ch := (ch-at STR i)
            :while (< i last-i)
            :until (alphanumericp ch)
            :do (incf i))
      ;; take all alphanum of `fname` and stop on the first non-alphanum after `fname` (ignoring spaces):
      (loop :initially (setf j last-i)
            :for ch := (ch-at STR j)
            :until (alphanumericp ch)
            :do (decf j)
            :finally (if (= j last-i)
                         (setf j nil)
                         (incf j))) ;; j=NIL|1st non-alphanum after fname
      (if j
          (setf fname (subseq STR i j))  ;; w/o non-alphanum at the end
          (setf fname (subseq STR i)))
      `((fname . ,fname)
        (fname-start . ,i)
        (fname-stop . ,(unless (member (ch-at STR j) *unicode-whitespace-chars*) j))))))


(defun parse-line-as-tree (PARSED-LINES STR)
  "Detects that the line looks as a line from `tree`-like output. Returns
  NIL (not `tree`-like line) or <parsed-line> modifying PARSED-LINES"
  (let* ((marked-up-str (markup-line-as-tree STR))
         (fname (cdr (assoc 'fname marked-up-str)))
         (fname-start (cdr (assoc 'fname-start marked-up-str)))
         (fname-stop (cdr (assoc 'fname-stop marked-up-str)))
         (parsed-line nil))
    (when marked-up-str
      (symbol-macrolet ;; XXX "let" working as #define (macro-substitution), so save setf-ability
          ((state-indents (<tree-state>-indents (<parsed-lines>-tree-state PARSED-LINES)))
           (state-fnames (<tree-state>-fnames (<parsed-lines>-tree-state PARSED-LINES)))
           (last-state-indent (or (car state-indents) 0)))
        ;; TODO maybe to add to as-tree list ? Not in parse-line?
        (setf
         parsed-line
         (progn
           ;; set fsobj to :dir/:file from the trailing / if it is allowed:
           (if (and (<parsed-lines>-dir-from-final-slash PARSED-LINES)
                    fname-stop
                    (char= #\/ (ch-at STR fname-stop)))
               (setf fsobj :dir)
               (setf fsobj :file))
           (cond
             ((< fname-start last-state-indent)
              ;; depth decreased, so I have to pop items from the tree-state:
              ;; pop indents until stacked indent = current indent (fname-start) if the current indent < last-state-indent:
              (multiple-value-bind (new-indents poped-num) (pop-until state-indents (eq-to fname-start) :include t)
                (when poped-num ;; when poped to existing indent ;; TODO what if we return to the zero-indent?
                  ;; (dbg (format nil "BEFORE! poped-num: ~A ■ state-indents: ~A ■ state-fnames: ~A ■ fname: ~A ■ fname-start: ~A ~%"
                  ;;              poped-num state-indents state-fnames fname fname-start))
                  (setf state-indents new-indents)
                  (setf state-fnames (subseq state-fnames poped-num))
                  (setf fname (path-parts-to-str state-fnames :part fname)) ;; fname is a/b/c now
                  ;; (dbg (format nil "AFTER poped-num: ~A ■ state-indents: ~A ■ state-fnames: ~A ■ fname: ~A~%"
                  ;;              poped-num state-indents state-fnames fname))
                  (make-<parsed-line> :format :tree :fname fname :fsobj fsobj))))
             ((> fname-start last-state-indent)
              ;; set my (:tree) last parsed line's `fsobj` to :dir - we enter deeper (coz fname-start > last-state-indent):
              (modify-last-parsed-line PARSED-LINES
                                       :tree
                                       (lambda (last-parsed-line)
                                         (setf (<parsed-line>-fsobj last-parsed-line) :dir)
                                         ;; (dbg (format nil "!!!!!!L!!!! ~A~%" last-parsed-line))
                                         last-parsed-line))
              (setf state-indents (cons fname-start state-indents))
              ;; (dbg (format t "1: fname: ~A state-fnames: ~X~%" fname state-fnames))
              (setf state-fnames (cons fname state-fnames))
              ;; (dbg (format t "2: fname: ~A state-fnames: ~X~%" fname state-fnames))
              (setf fname (path-parts-to-str (reverse state-fnames))) ;; fname is a/b/c now
              (make-<parsed-line> :format :tree :fname fname :fsobj fsobj))
             ((= fname-start last-state-indent)
              (if state-fnames
                  (setf (car state-fnames) fname)
                  (setf state-fnames (list fname)))
              (setf fname (path-parts-to-str (reverse state-fnames))) ;; fname is a/b/c now
              ;; (dbg (format nil "WHEN= state-fnames: ~A■fname: ~A■last-state-indent: ~A■fname-start: ~A~%"
              ;;              state-fnames fname last-state-indent fname-start))
              (make-<parsed-line> :format :tree :fname fname :fsobj fsobj)))))
        (when parsed-line
          ;; (dbg (format nil "!!!!!!!! before to add ~S (parsed-line: ~S)~%" PARSED-LINES parsed-line))
          (add-to-parsed-lines PARSED-LINES :tree parsed-line)
          ;; (dbg (format t "!!!!!!!! after add ~X~%" PARSED-LINES))
          parsed-line)))))

(defun parse-line-as-find (PARSED-LINES STR)
  "Detects that the line looks as a line from `find`-like output. Returns
  NIL (not `find`-like line) or <parsed-line> modifying PARSED-LINES"
  (let* ((last-i (1- (length STR)))
         (fname nil)
         (lines (get-parsed-lines PARSED-LINES :find))
         (last-parsed-line (car (last lines)))
         (last-parsed-line-fname (when last-parsed-line (<parsed-line>-fname last-parsed-line)))
         (unquoted-str (unquote-str STR)))
    (when
        (and (>= last-i 0)
             ;; it should not end with ':':
             (char/= #\: (ch-at STR last-i)))
      (when (or (starts-with-p unquoted-str "/")
                (starts-with-p unquoted-str "./")
                (starts-with-p unquoted-str "../"))
        (setf fname unquoted-str))
      (when (not (emptyp fname))
        (when (and last-parsed-line (starts-with-p fname last-parsed-line-fname))
          ;; Last parsed line  (of :find format) is prefix of mine, then it was a dir,
          ;; me - an entry inside that dir, so mark as :dir the last parsed line's fsobj:
          (modify-last-parsed-line PARSED-LINES
                                   :find
                                   (lambda (last-parsed-line)
                                     (setf (<parsed-line>-fsobj last-parsed-line) :dir)
                                     last-parsed-line)))
        (add-to-parsed-lines PARSED-LINES :find
                             (make-<parsed-line> :format :find :fname fname :fmode 0 :fsobj :file))))))


;; Specification of a bit in strings like "-rw-r--r--":
(defstruct <fmode-spec>
  (pos 0 :type integer)
  (char nil :type character)
  (value nil :type integer)
  (descr nil :type string))


;; Bits specifications for "-rw-r--r--" string:
(defparameter *fmode-bits* (make-array 10))
;; Initialization of bits specifications for "-rw-r--r--" strings:
(dotimes (i 10) (setf (aref *fmode-bits* i) (make-hash-table :test 'equal)))
(defun defmode-in (VAR POS CHAR VALUE DESCR)
  (when (and (>= POS 0) (< POS (length *fmode-bits*)))
    (setf (gethash CHAR (aref VAR POS))
          (make-<fmode-spec> :pos POS :char CHAR :value VALUE :descr DESCR))))

;; Character positions 0-9 of "-rw-r--r--":
(defmode-in *fmode-bits* 0 #\- #x8000 "regular file")
(defmode-in *fmode-bits* 0 #\d #x4000 "directory")
(defmode-in *fmode-bits* 0 #\l #xA000 "symbolic link")
(defmode-in *fmode-bits* 0 #\c #x2000 "character device")
(defmode-in *fmode-bits* 0 #\b #x6000 "block device")
(defmode-in *fmode-bits* 0 #\p #x1000 "named pipe")
(defmode-in *fmode-bits* 0 #\s #xC000 "socket")
(defmode-in *fmode-bits* 1 #\r #x0100 "owner read")
(defmode-in *fmode-bits* 1 #\- #x0000 "no owner read")
(defmode-in *fmode-bits* 2 #\w #x0080 "owner write")
(defmode-in *fmode-bits* 2 #\- #x0000 "no owner write")
(defmode-in *fmode-bits* 3 #\x #x0040 "owner exec")
(defmode-in *fmode-bits* 3 #\s #x0800 "setuid+exec")
(defmode-in *fmode-bits* 3 #\S #x0800 "setuid+no exec")
(defmode-in *fmode-bits* 3 #\- #x0000 "no owner exec")
(defmode-in *fmode-bits* 4 #\r #x0020 "group read")
(defmode-in *fmode-bits* 4 #\- #x0000 "no group read")
(defmode-in *fmode-bits* 5 #\w #x0010 "group write")
(defmode-in *fmode-bits* 5 #\- #x0000 "no group write")
(defmode-in *fmode-bits* 6 #\x #x0008 "group exec")
(defmode-in *fmode-bits* 6 #\s #x0400 "setgid+exec")
(defmode-in *fmode-bits* 6 #\S #x0400 "setgid+no exec")
(defmode-in *fmode-bits* 6 #\- #x0000 "no group exec")
(defmode-in *fmode-bits* 7 #\r #x0004 "other read")
(defmode-in *fmode-bits* 7 #\- #x0000 "no other read")
(defmode-in *fmode-bits* 8 #\w #x0002 "other write")
(defmode-in *fmode-bits* 8 #\- #x0000 "no other write")
(defmode-in *fmode-bits* 9 #\x #x0001 "other exec")
(defmode-in *fmode-bits* 9 #\t #x0200 "sticky+exec")
(defmode-in *fmode-bits* 9 #\T #x0200 "sticky+no exec")
(defmode-in *fmode-bits* 9 #\- #x0000 "no other exec")

(declaim (ftype (function (string array) (or null integer)) parse-fmode-str))
(defun parse-fmode-str (STR FMODE-SPECS)
  "Parses 10-characters string like \"-rw-r--r--\" to standard file mode value, if it is not
a 10-character string like this, nil is returned"
  (let* ((char-to-value (lambda (ch chs-map)
                          (let ((spec (gethash ch chs-map)))
                            (if spec
                                (<fmode-spec>-value spec)
                                ;; else if such char in such position is unknown - don't ignore it,
                                ;; ie, don't treat it as 0, but as NIL, which will lead to NIL result
                                nil))))
         (char-values (remove nil
                              ;; remove all NILs (positions with unknown chars):
                              ;; 1) it will lead to final NIL result
                              ;; 2) else reduce with OR (logior) will lead to error
                              ;;    "The value NIL is not of type INTEGER"
                              (map 'list char-to-value STR FMODE-SPECS)))
         (fmode (if (= (length *fmode-bits*) (length char-values))
                    (reduce #'logior char-values)
                    nil)))
    fmode))

(defun parse-line-as-ls1r (PARSED-LINES STR)
  "Detects that the line looks as a line from `ls -1R`-like output. Returns
  NIL (not `ls -1R`-like line) or <parsed-line> modifying PARSED-LINES"
  (let* ((last-i (1- (length STR)))
         (str-is-not-empty (>= last-i 0))
         (fsobj nil)
         (str-is-dir-hint (when str-is-not-empty (char= #\: (ch-at STR last-i))))
         (fname-extraction (extract-ls-fname (if str-is-dir-hint
                                                 (subseq STR 0 last-i)
                                                 STR)))
         (fname (when (eq 'fname (car fname-extraction)) (cdr fname-extraction)))
         (fail-msg (when (eq 'fail (car fname-extraction)) (cdr fname-extraction))))
    (when (and (>= last-i 0)
               (eq nil (parse-fmode-str STR *fmode-bits*)))
      (symbol-macrolet
          ((state-dir (<ls1r-state>-dir (<parsed-lines>-ls1r-state PARSED-LINES)))
           (state-fname-hashes (<ls1r-state>-fname-hashes (<parsed-lines>-ls1r-state PARSED-LINES))))
        (cond
          ((and str-is-dir-hint fname)  ;; Hint of yet another directory ("xyz:")
           (setf fsobj :dir)
           (multiple-value-bind (fname-pos fname-exists) (gethash fname state-fname-hashes)
             (if fname-exists
                 ;; If such fname has known position, find its <parsed-line> and set its fsobj to :dir,
                 ;; btw, if it exists, then it has corresponding item in parsed lines of its format,
                 ;; so we don't check NIL==get-parsed-lines (they are not empty):
                 (setf (<parsed-line>-fsobj
                        (nth fname-pos
                             (get-parsed-lines PARSED-LINES :ls1r)))
                       :dir)
                 ;; else - remember fname's position:
                 (setf (gethash fname state-fname-hashes)
                       (hash-table-count state-fname-hashes))))
           (setf state-dir fname)
           (add-to-parsed-lines PARSED-LINES :ls1r
                                (make-<parsed-line> :format :ls1r :fname fname :fmode 0 :fsobj fsobj)))
          (fname
           (setf fname (path-parts-to-str (list state-dir fname)))
           ;; remember the position of fname:
           (setf (gethash fname state-fname-hashes)
                 (hash-table-count state-fname-hashes))
           (setf fsobj :file)
           (add-to-parsed-lines PARSED-LINES :ls1r
                                (make-<parsed-line> :format :ls1r :fname fname :fmode 0 :fsobj fsobj)))
          ((<parsed-lines>-verbose PARSED-LINES)
           (setf (<parsed-lines>-ls1r-fail-msg PARSED-LINES)
                 (format t "ERROR: cannot parse '~A': ~A~%" STR (or fail-msg "unknown error")))))
        ;; (dbg (format nil "!!!!!!!!!!!!! STR: ~A  fname: ~A~%~A~%" STR fname
        ;;              (maphash (lambda (k v) (format t "  ~A => ~A~%" k v)) state-fname-hashes)) nil :cond t)
        ))))

(defun match-total-files-str (STR)
  "Matches a string \"total [0-9]+\" without regexp. If cannot match it, returns NIL"
  (let ((i 0) (total-str "total "))
    (and
     (loop :initially (setf i 0)
           :for ch1 :across total-str
           :for ch2 :across STR
           :do (incf i)
           :while (char= ch1 ch2)
           :finally (return (= i (length total-str))))
     (loop :for ch :across (subseq STR i)
           :do (incf i)
           :while (digit-char-p ch)
           :finally (return (and
                             ;; at least one digit was found:
                             (> i (length total-str))
                             ;; ch is NIL if zero increments, so it's second condition.
                             ;; it means we stopped on digit or whitespace:
                             (or (digit-char-p ch) (find ch "\r\n\t "))))))))

(defun parse-line-as-ls1rl (PARSED-LINES STR)
  "Detects that the line looks as a line from `ls -1Rl`-like output. Returns
  NIL (not `ls -1Rl`-like line) or <parsed-line> modifying PARSED-LINES"
  "Detects that the line looks as a line from `ls -1R`-like output. Returns
  NIL (not `ls -1R`-like line) or <parsed-line> modifying PARSED-LINES"
  (let* ((last-i (1- (length STR)))
         (str-is-not-empty (>= last-i 0))
         (fsobj nil)
         (str-is-dir-hint (when str-is-not-empty (char= #\: (ch-at STR last-i))))
         (str-is-total-hint (match-total-files-str STR))
         (fname-extraction (extract-ls-fname (if (and str-is-dir-hint (not str-is-total-hint))
                                                 (subseq STR 0 last-i)
                                                 STR)))
         (fname (when (eq 'fname (car fname-extraction)) (cdr fname-extraction)))
         (fmode (when (and (not str-is-dir-hint) (not str-is-total-hint)) (parse-fmode-str STR *fmode-bits*)))
         (fmode-int (or fmode 0))
         (fmode-dir (/= 0 (logand #x4000 fmode-int)))
         (fail-msg (when (eq 'fail (car fname-extraction)) (cdr fname-extraction))))
    (when (and str-is-not-empty (not str-is-total-hint))
      (symbol-macrolet
          ((state-dir (<ls1rl-state>-dir (<parsed-lines>-ls1rl-state PARSED-LINES)))
           (state-fname-hashes (<ls1rl-state>-fname-hashes (<parsed-lines>-ls1rl-state PARSED-LINES))))
        (cond
          ((and str-is-dir-hint fname)  ;; Hint of yet another directory ("xyz:")
           (setf fsobj :dir)
           (multiple-value-bind (fname-pos fname-exists) (gethash fname state-fname-hashes)
             (if fname-exists
                 ;; If such fname has known position, find its <parsed-line> and set its fsobj to :dir,
                 ;; btw, if it exists, then it has corresponding item in parsed lines of its format,
                 ;; so we don't check NIL==get-parsed-lines (they are not empty):
                 (setf (<parsed-line>-fsobj
                        (nth fname-pos
                             (get-parsed-lines PARSED-LINES :ls1rl)))
                       :dir)
                 ;; else - remember fname's position:
                 (setf (gethash fname state-fname-hashes)
                       (hash-table-count state-fname-hashes))))
           (setf state-dir fname)
           (add-to-parsed-lines PARSED-LINES :ls1rl
                                (make-<parsed-line> :format :ls1rl :fname fname :fmode fmode-int :fsobj fsobj)))
          ((and fmode fname)
           (setf fname (path-parts-to-str (list state-dir fname)))
           ;; remember the position of fname:
           (setf (gethash fname state-fname-hashes)
                 (hash-table-count state-fname-hashes))
           (if fmode-dir (setf fsobj :dir) (setf fsobj :file))
           (add-to-parsed-lines PARSED-LINES :ls1rl
                                (make-<parsed-line> :format :ls1rl :fname fname :fmode fmode-int :fsobj fsobj)))
          ((<parsed-lines>-verbose PARSED-LINES)
           (setf (<parsed-lines>-ls1rl-fail-msg PARSED-LINES)
                 (format t "ERROR: cannot parse '~A': ~A~%" STR (or fail-msg "unknown error")))))
        ;; (dbg (format nil "!!!!!!!!!!!!! STR: ~A  fname: ~A~%~A~%" STR fname
        ;;              (maphash (lambda (k v) (format t "  ~A => ~A~%" k v)) state-fname-hashes)) nil :cond t)
        ))))


(declaim (ftype (function (<format>) (function (<parsed-lines> string) (or null <parsed-line>))) get-parse-func))
(defun get-parse-func (FORMAT)
  (ecase FORMAT
    (:tree #'parse-line-as-tree)
    (:find #'parse-line-as-find)
    (:ls1r #'parse-line-as-ls1r)
    (:ls1rl #'parse-line-as-ls1rl)))

(declaim (ftype (function (<parsed-lines> string) (or null list)) parse-line))
(defun parse-line (PARSED-LINES STR)
  "Parses string STR until there are active formats (formats that still parse),
returns a list of lists (parsed strings) or null if nothing can be parsed more"
  (let* ((active-formats (get-most-parsed-lines PARSED-LINES))
         (parse-funcs (mapcar #'get-parse-func
                              (mapcar #'car active-formats)))
         (active-format-parsed-lines ;; parsed lines from active formats (one line from every active format) w/o nils
           (progn
             (dolist (fmt +formats+) (reset-parsed-lines-fails PARSED-LINES fmt))
             (remove nil
                     (mapcar (lambda (parse-func) (funcall parse-func PARSED-LINES STR))
                             parse-funcs)))))
    (when (and (not active-format-parsed-lines) (<parsed-lines>-verbose PARSED-LINES))
      ;; report errors for verbose mode:
      (dolist (fmt +formats+)
        (let ((fmt-fail-msg (get-parsed-lines-fail-msg PARSED-LINES fmt)))
          (when fmt-fail-msg (format *error-output* "*** ERROR [~A]: ~A~%" fmt fmt-fail-msg)))))
    (dbg (format nil "!!!!!!!!!!!!!!! ~A~%  active-formats: ~A~%" STR active-formats))
    (when (= 1 (length active-formats))
      ;; If there is only 1 active format, then set it as the detected one:
      (setf (<parsed-lines>-detected-format PARSED-LINES) (caar active-formats)))
    active-format-parsed-lines))

;; XXX "Permission denied" containing lines must be ignored!
;; XXX Also "cannot open directory"
;; Also tree can print attributes of files
;; Also I should learn (while I detect) where file starts:
;; +-----file
;; +-----  file  <- all lines will start with the same spacing policy

;; TODO add :unknown to :dir :file - CLI opt will force it to dir/file


(defparameter *unicode-whitespace-chars*
  '(#\Space #\Tab #\Newline #\Return
    #\No-break_space           ; U+00A0
    #\Ogham_space_mark         ; U+1680
    #\En_quad                  ; U+2000
    #\Em_quad                  ; U+2001
    #\En_space                 ; U+2002
    #\Em_space                 ; U+2003
    #\Three-per-em_space       ; U+2004
    #\Four-per-em_space        ; U+2005
    #\Six-per-em_space         ; U+2006
    #\Figure_space             ; U+2007
    #\Punctuation_space        ; U+2008
    #\Thin_space               ; U+2009
    #\Hair_space               ; U+200A
    #\Zero_width_space         ; U+200B
    #\Narrow_no-break_space    ; U+202F
    #\Medium_mathematical_space; U+205F
    #\Ideographic_space))      ; U+3000


(defun trim-any-whitespaces (string)
  "Like Python's str.strip()"
  (string-trim *unicode-whitespace-chars* string))

;; TODO ../ in the beginning is also possible!!!
;; ending can be @, =, etc...

(defun ls-1r-line-det (line)  ;; XXX Must be ran after `ls-1rl-line-det`
  (let ((last-i (1- (length line)))
        (uniq-features 0))
    (when
        (or
         (when (string= "" (trim-any-whitespaces line)) (incf uniq-features))
         (and (>= last-i 0)
              ;; If there are spaces, the line must start with ' or " (else: not our case, T)
              (implies (find #\Space line :test #'char=) (case (ch-at line 0) (#\' t) (#\" t)))
              (case (ch-at line 0)
                ((#\' #\" #\/ #\.) t)
                (t (alphanumericp (ch-at line 0))))
              (or (and (char= #\: (ch-at line last-i))
                       (or (starts-with-p line "/")
                           (starts-with-p line "./")
                           (starts-with-p line "../")
                           (starts-with-p line "'./")
                           (starts-with-p line "\"./")
                           (starts-with-p line "'../")
                           (starts-with-p line "\"../")))
                  ;; TODO windows?
                  (char/= #\: (ch-at line last-i)))))
      (list (cons :uniq-features uniq-features)))))


(defun ls-1rl-line-det (line)
  (let* ((last-i (1- (length line)))
         (total-str "total ")
         (file-delim (case (ch-at line last-i)
                       (#\' #\')
                       (#\" #\")
                       (t #\Space)))
         (attrs 0) (i 0) (filechars 0) (mtimechars 0)
         (uniq-features 0))
    (when
        (and (> last-i 0)
             (or (and (starts-with-p line total-str) (> last-i (length total-str))
                      (digit-char-p (ch-at line (length total-str))))
                 (and (char= #\: (ch-at line last-i))
                      (or (starts-with-p line "/")
                          (starts-with-p line "./")
                          (starts-with-p line "../")
                          (starts-with-p line "'./")
                          (starts-with-p line "\"./")
                          (starts-with-p line "'../")
                          (starts-with-p line "\"../")))
                 (when
                     (and
                      ;; 17 - minimum length with minimal column sizes and 1 space-delimiter:
                      (>= last-i 17)
                      (loop :for ch := (ch-at line i)
                            :while (< i last-i)
                            :while (or (char= ch #\-) (char= ch #\r) (char= ch #\w) (char= ch #\x)
                                       (char= ch #\l) (char= ch #\b) (char= ch #\c) (char= ch #\p)
                                       (char= ch #\s) (char= ch #\D) (char= ch #\P) (char= ch #\n)
                                       (char= ch #\C) (char= ch #\M) (char= ch #\?) (char= ch #\S)
                                       (char= ch #\t) (char= ch #\T) (char= ch #\d)
                                       (char= ch #\+) (char= ch #\.) (char= ch #\@))
                            :while (char/= ch #\Space)
                            :do (incf attrs) (incf i)
                            :finally (return (or (= attrs 10) (= attrs 11))))
                      (char= (ch-at line i) #\Space)
                      (loop :for j :downfrom last-i :to 0
                            :for ch = (ch-at line j)
                            :while (or (char/= ch file-delim) (= j last-i))
                            :do (incf filechars)
                            :finally
                               (when
                                   ;; Files with spaces or '/" are quoted with "...'..." and
                                   ;; '..."...'. If file is not quoted, when we hit the space,
                                   ;; we counted file size correctly. But when we hit '/", we
                                   ;; counted the rightmost '/" and all file symbols, but not
                                   ;; the leftmost '/", to do it, we have to do yet another
                                   ;; iteration! So, when the exit-char hit by us is not space,
                                   ;; it is some quote-symbol, so increment filechars to treat
                                   ;; 'xxx' as 5 symbols, not 4
                                   (char/= ch #\Space) (incf filechars))
                               ;; (format t "'~A' (~C)~%" filechars file-delim)
                               (return (> filechars 0)))
                      (loop :for j :downfrom (- last-i filechars 1) :to 0
                            :for ch = (ch-at line j)
                            :while (or (digit-char-p ch) (char= ch #\:))
                            :do (incf mtimechars) ;; last column of mtime is HH:MM or YYYY
                            :finally (return (or (= mtimechars 4) (= mtimechars 5)))))
                   (incf uniq-features 1))))
      (list (cons :uniq-features uniq-features)))))


(defun safe-assoc (pairs kw &KEY default)
  (let ((p (and (listp pairs)
                (assoc kw (remove-if-not #'consp pairs)))))
    (if p (cdr p) default)))


(defun get-uniq-features (det-result &optional default)
  "Returns :uniq-features from a determination result, which usually is
  NIL or '((:uniq-features) <int>)...) or something else. If it cannot
  be got, then it returns `default` (NIL or passed)''"
  (safe-assoc det-result :uniq-features :default default))


(defun det-format (funcs lines)
  "Finds the function (among `funcs`, returned as an index) which is mostly satisfied
  on `lines` (at least once! Else - returns nil)"
  (let* ((aggregate-func-lines-results
           (lambda (acc e)
             (if e
                 (list (1+ (car acc)) (+ (get-uniq-features e 0) (cadr acc)))
                 acc)))
         (funcs-over-lines-results (mapcar (lambda (fn) (mapcar fn lines)) funcs))
         (funcs-results-0 (mapcar (lambda (lines-results)
                                    (reduce aggregate-func-lines-results
                                            lines-results
                                            :initial-value (list 0 0)))
                                  funcs-over-lines-results))
         ;; just enumerated (0 ...) (1 ...)... :
         (funcs-results-1 (loop :for e :in funcs-results-0
                                :for i :from 0
                                :collect (cons i e)))
         (sorted-by-hits (sort funcs-results-1
                               (lambda (a b)
                                 (or (> (car a) (car b))
                                     (and (= (car a) (car b))
                                          (> (cadr a) (cadr b)))))
                               :key #'cdr)))
    (and funcs lines (caar sorted-by-hits))))


  ;; (let* ((funcs-hits (mapcar (lambda (fn)
  ;;                              (count-if fn lines))
  ;;                            funcs))
  ;;        (max-hits-num (apply #'max funcs-hits)))
  ;;   (and (> max-hits-num 0)
  ;;        (position max-hits-num funcs-hits))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defparameter *OS* nil)

(defun det-*OS* ()
  (cond ((member :windows *features*) :windows)
        ((member :unix *features*)
         (cond ((member :darwin *features*) :mac)
               (t :unix)))
        (t (error "OS not recognized!"))))


;; Path separator (as a string)
(defparameter *path-sep* nil)

(defun det-*path-sep* ()
  (ecase *OS* (:windows "\\") (:unix "/") (:mac "/")))


;; Known dir listing formats
(defconstant +fmt+ '(:ls :find :tree))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Logic ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun detect-series (INPUT CLASSIFIERS)
  (let ((results nil)
        ;; current-result is (class-of-series . the-length-of-series):
        (current-result (cons -1 0))
        ;; objects in INPUT that cannot be classified (index in CLASSIFIERS), will be
        ;; marked with index out of bounds, ie, max allowed index + 1 (or their length):
        (unknown-class (length CLASSIFIERS))
        ;; did we classified the object using all CLASSIFIERS on the loop:
        (classified nil))
    (unless (or (null INPUT) (null CLASSIFIERS))  ;; just ignore empty INPUT/CLASSIFIERS
      (dolist (obj INPUT)
        (setf classified nil)
        (dotimes (c (length CLASSIFIERS))
          (when (funcall (nth c CLASSIFIERS) obj)
            ;; classified by the current classifier or a new one, anyway, must be marked
            ;; as classified, else it will be marked as unknown class:
            (setf classified t)
            (if (= c (car current-result))
                (setf (cdr current-result) (1+ (cdr current-result)))
                (progn
                  (unless (= -1 (car current-result))
                    (push current-result results))
                  (setf current-result (cons c 1))))))
        (unless classified
          ;; if no CLASSIFIERS recognized obj, then it will be unknown-class. But first,
          ;; we look if the current-result already is unknown-class - if yes, then we
          ;; expand it (increment its length). If it was some known classifier, we add
          ;; it to all results. Else - just replace it (such class is -1):
          (cond
            ((= -1 (car current-result))
             (setf current-result (cons unknown-class 1)))
            ((= unknown-class (car current-result))
             (setf (cdr current-result) (1+ (cdr current-result))))
            (t (push current-result results)
               (setf current-result (cons unknown-class 1)))))))
    ;; the last series, not added by new one, bcs no more iterations - chars ended:
    (unless (= -1 (car current-result))
      (push current-result results))
    (nreverse results)))


;; (defun cmp-slot (a b getter &optional (eqfn #'equal))
;;   (let ((va (funcall getter a))
;;         (vb (funcall getter b)))
;;     (unless (funcall eqfn va vb)
;;       (format nil "~A: unequal~%  ~A~%vs.~%  ~A" getter va vb))))

;; (defgeneric cmp-my-structs (a b))

;; (defmethod cmp-my-structs ((a <parsed-line>) (b <parsed-line>))
;;   (format nil "~{~a~^~%~}"
;;            (remove nil (list (cmp-slot a b #'<parsed-line>-format)
;;                              (cmp-slot a b #'<parsed-line>-fname)
;;                              (cmp-slot a b #'<parsed-line>-fmode)
;;                              (cmp-slot a b #'<parsed-line>-fsobj)))))

;; (defmethod cmp-my-structs ((a <tree-state>) (b <tree-state>))
;;   (format nil "~{~a~^~%~}"
;;           (remove nil (list (cmp-slot a b #'<tree-state>-indents)
;;                             (cmp-slot a b #'<tree-state>-fnames)))))

;; (defun cmp-struct-lists (l1 l2 &key (title ""))
;;   (let ((len1 (length l1)) (len2 (length l2)))
;;     (cond
;;       ((> len1 len2) (list (format nil "First list is longer than the second ~A" title)))
;;       ((< len1 len2) (list (format nil "Second list is longer than the first ~A" title)))
;;       ((= len1 len2) (mapcar #'cmp-my-structs l1 l2)))))


;; (defmethod cmp-my-structs ((a <parsed-lines>) (b <parsed-lines>))
;;   (format nil "~{~a~^~%~}"
;;           (remove nil `(,(cmp-slot a b #'<parsed-lines>-detected-format)
;;                         ,(cmp-slot a b #'<parsed-lines>-dir-from-final-slash)
;;                         ,@(cmp-struct-lists (<parsed-lines>-as-tree a) (<parsed-lines>-as-tree b) :title "(as-tree)")
;;                         ,@(cmp-struct-lists (<parsed-lines>-as-find a) (<parsed-lines>-as-find b) :title "(as-find)")
;;                         ,@(cmp-struct-lists (<parsed-lines>-as-ls1r a) (<parsed-lines>-as-ls1r b) :title "(as-ls1r)")
;;                         ,@(cmp-struct-lists (<parsed-lines>-as-ls1rl a) (<parsed-lines>-as-ls1rl b) :title "(as-ls1rl)")
;;                         ;; ,@(mapcar #'cmp-my-structs (<parsed-lines>-as-tree a) (<parsed-lines>-as-tree b))
;;                         ;; ,@(mapcar #'cmp-my-structs (<parsed-lines>-as-find a) (<parsed-lines>-as-find b))
;;                         ;; ,@(mapcar #'cmp-my-structs (<parsed-lines>-as-ls1r a) (<parsed-lines>-as-ls1r b))
;;                         ;; ,@(mapcar #'cmp-my-structs (<parsed-lines>-as-ls1rl a) (<parsed-lines>-as-ls1rl b))
;;                         ,(cmp-my-structs (<parsed-lines>-tree-state a) (<parsed-lines>-tree-state b))))))


(defmacro hash-literal (&rest pairs)
  "Create a hash table from alternating key/value pairs:

CL-USER> (hash-literal :a '(a b c) :b (hash-literal :c '(1 2 3)))
#<HASH-TABLE :TEST EQUAL :COUNT 2 {10026C5E73}>
"
  `(let ((table (make-hash-table :test 'equal)))
     ,@(loop for (key val) on pairs by #'cddr
             collect `(setf (gethash ,key table) ,val))
     table))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Test ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(5am:def-suite :suite1 :description "EasyTree Test Suite")
(5am:in-suite :suite1)
(5am:test get-cons-with-longest-list--test1
          (5am:is (equal '((1) (2))
                         (get-cons-with-longest-list '((1) (2))))))

(5am:test get-cons-with-longest-list--test1
          (5am:is (equal '((2 11 12 13))
                         (get-cons-with-longest-list '((1 2 3) (2 11 12 13))))))

(5am:test get-cons-with-longest-list--test2
          (5am:is (equal '((1 2 3) (2 11 12))
                         (get-cons-with-longest-list '((1 2 3) (2 11 12))))))

(5am:test get-cons-with-longest-list--test3
          (5am:is (equal '((1 2 3) (2 11 12))
                         (get-cons-with-longest-list '((1 2 3) (2 11 12) ()))))) ;; () == nil

(5am:test get-cons-with-longest-list--test4
          (5am:is (equal '((1 2 3) (2 11 12))
                         (get-cons-with-longest-list '((1 2 3) (2 11 12) (3))))))

(5am:test get-cons-with-longest-list--test5
          (5am:is (equal '((1 2 3) (2 11 12))
                         (get-cons-with-longest-list '((1 2 3) (2 11 12) (3 4))))))

(5am:test get-cons-with-longest-list--test6
          (5am:is (equal '((1 2 3) (2 11 12) (3 4 5))
                         (get-cons-with-longest-list '((1 2 3) (2 11 12) (3 4 5))))))

(5am:test get-cons-with-longest-list--test7
          (5am:is (equal '((3 4 5 6))
                         (get-cons-with-longest-list '((1 2 3) (2 11 12) (3 4 5 6))))))

(5am:test pop-until--test1
          (5am:is (equal '((4 5) 3)
                         (multiple-value-list
                          (pop-until '(1 2 3 4 5) (lambda (x) (= x 4)))))))

(5am:test pop-until--test2
          (5am:is (equal '((5) 4)
                         (multiple-value-list
                          (pop-until '(1 2 3 4 5) (lambda (x) (= x 4)) :include t)))))

(5am:test pop-until--test3
          (5am:is (equal '(nil)
                         (multiple-value-list
                          (pop-until '(1 2 3 4 5) (lambda (x) (= x 10)) :include t)))))

(5am:test pop-until--test4
          (5am:is (equal '(nil 5)
                         (multiple-value-list
                          (pop-until '(1 2 3 4 5) (lambda (x) (= x 5)) :include t)))))

(5am:test pop-until--test5
          (5am:is (equal '((5) 4)
                         (multiple-value-list
                          (pop-until '(1 2 3 4 5) (lambda (x) (= x 5)))))))

(5am:test pop-until--test6
          (5am:is (equal '((1 2 3 4 5) 0)
                         (multiple-value-list
                          (pop-until '(1 2 3 4 5) (lambda (x) (= x 1)))))))

(5am:test pop-until--test7
          (5am:is (equal '((2 3 4 5) 1)
                         (multiple-value-list
                          (pop-until '(1 2 3 4 5) (lambda (x) (= x 1)) :include t)))))

(5am:test pop-until--test8
          (5am:is (equal '((4 5) 3)
                         (multiple-value-list
                          (pop-until '(1 2 3 4 5) (eq-to 3) :include t)))))

(5am:test path-parts-to-str--test1
          (5am:is (equal "aaa/bbb"
                         (path-parts-to-str '("aaa" "bbb")))))

(5am:test path-parts-to-str--test2
          (5am:is (equal "aaa/bbb/ccc"
                         (path-parts-to-str '("aaa" "bbb") :part "ccc"))))

(5am:test path-parts-to-str--test3
          (5am:is (equal "aaa!bbb" (path-parts-to-str '("aaa" "bbb") :sep "!"))))

(5am:test markup-line-as-tree--test1
          (5am:is (equal nil (markup-line-as-tree ""))))

(5am:test markup-line-as-tree--test2
          (5am:is (equal '((fname . "file") (fname-start . 0) (fname-stop))
                         (markup-line-as-tree "file  "))))

(5am:test markup-line-as-tree--test3
          (5am:is (equal
                   '((fname . "file") (fname-start . 6) (fname-stop))
                   (markup-line-as-tree "  +---file   "))))

(5am:test markup-line-as-tree--test4
          (5am:is (equal '((fname . "file") (fname-start . 7) (fname-stop . 11))
                         (markup-line-as-tree "  +--- file/  "))))

(5am:test parse-line-as-tree--test1
          (5am:is (equalp
                   nil
                   (parse-line-as-tree (make-<parsed-lines>)
                                       ""))))

(5am:test parse-line-as-tree--test2
          (5am:is (equalp
                   (make-<parsed-line> :format :tree :fname "file" :fmode 0 :fsobj :file)
                   (parse-line-as-tree (make-<parsed-lines>)
                                       "file"))))

(5am:test parse-line-as-tree--test3
          (5am:is (equalp
                   (make-<parsed-lines>
                    :dir-from-final-slash t
                    :as-tree (list (make-<parsed-line> :format :tree :fname "file" :fsobj :dir))
                    :tree-state (make-<tree-state> :indents (list 9) :fnames (list "file")))
                   (let ((pls (make-<parsed-lines>)))
                     (parse-line-as-tree pls "   +---- file/  ")
                     pls))))


(5am:test parse-line-as-tree--test4
          (5am:is (equalp
                   (make-<parsed-lines>
                    :dir-from-final-slash t
                    :as-tree (list (make-<parsed-line> :format :tree :fname "etc" :fsobj :dir)
                                   (make-<parsed-line> :format :tree :fname "etc/file" :fsobj :file))
                    :tree-state (make-<tree-state> :indents '(9 0) :fnames '("file" "etc")))
                   (let ((pls
                           (make-<parsed-lines>
                            :dir-from-final-slash t
                            :as-tree (list (make-<parsed-line> :format :tree :fname "etc" :fsobj :dir))
                            :tree-state (make-<tree-state> :indents '(0) :fnames '("etc")))))
                     (parse-line-as-tree pls "   +---- file  ")
                     pls))))


(5am:test parse-line-as-tree--test5
          (5am:is (equalp
                   (make-<parsed-lines>
                    :dir-from-final-slash t
                    :as-tree (list (make-<parsed-line> :format :tree :fname "etc" :fsobj :dir)
                                   (make-<parsed-line> :format :tree :fname "etc/dir" :fsobj :dir)
                                   (make-<parsed-line> :format :tree :fname "etc/dir/file-1" :fsobj :file)
                                   (make-<parsed-line> :format :tree :fname "etc/dir/file-2" :fsobj :file)
                                   (make-<parsed-line> :format :tree :fname "etc/file-3" :fsobj :file)
                                   (make-<parsed-line> :format :tree :fname "tmp" :fsobj :dir))
                    :tree-state (make-<tree-state> :indents nil :fnames '("tmp")))
                   (let ((pls (make-<parsed-lines>)))
                     (parse-line-as-tree pls "etc")
                     (parse-line-as-tree pls "+---dir/")
                     (parse-line-as-tree pls "     +----file-1")
                     (parse-line-as-tree pls "     +----file-2")
                     (parse-line-as-tree pls "+---file-3")
                     (parse-line-as-tree pls "tmp/")
                     pls))))

(5am:test parse-line-as-find--test1
          (5am:is (equalp
                   nil
                   (parse-line-as-find (make-<parsed-lines>)
                                       ""))))

(5am:test parse-line-as-find--test2
          (5am:is (equalp
                   (make-<parsed-lines>
                    :dir-from-final-slash t
                    :as-find (list (make-<parsed-line> :format :find :fname "./dir1" :fsobj :dir)
                                   (make-<parsed-line> :format :find :fname "./dir1/dir 11" :fsobj :dir)
                                   (make-<parsed-line> :format :find :fname "./dir1/dir 11/file11" :fsobj :file)
                                   (make-<parsed-line> :format :find :fname "./dir1/dir 11/file12" :fsobj :file)
                                   (make-<parsed-line> :format :find :fname "./dir2/dir 21" :fsobj :dir)
                                   (make-<parsed-line> :format :find :fname "./dir2/dir 21/file21" :fsobj :file)
                                   (make-<parsed-line> :format :find :fname "./dir3" :fsobj :file))
                    :tree-state (make-<tree-state> :indents nil :fnames nil))
                   (let ((pls (make-<parsed-lines>)))
                     (parse-line-as-find pls "./dir1")
                     (parse-line-as-find pls "'./dir1/dir 11'")
                     (parse-line-as-find pls "'./dir1/dir 11/file11'")
                     (parse-line-as-find pls "'./dir1/dir 11/file12'")
                     (parse-line-as-find pls "'./dir2/dir 21'")
                     (parse-line-as-find pls "'./dir2/dir 21/file21'")
                     (parse-line-as-find pls "./dir3")
                     pls))))

(5am:test parse-fmode-str--test1
          (5am:is (eql
                   #x81ed
                   (parse-fmode-str "-rwxr-xr-x" *fmode-bits*))))

(5am:test parse-fmode-str--test2
          (5am:is (eql
                   nil
                   (parse-fmode-str "" *fmode-bits*))))

(5am:test parse-fmode-str--test3
          (5am:is (eql
                   nil
                   (parse-fmode-str "-rwxr-" *fmode-bits*))))

(5am:test parse-fmode-str--test4
          (5am:is (eql
                   #x8000
                   (parse-fmode-str "----------" *fmode-bits*))))

(5am:test parse-fmode-str--test5
          (5am:is (eql
                   #x81ed
                   (parse-fmode-str "-rwxr-xr-xABC" *fmode-bits*))))

(5am:test parse-fmode-str--test6
          (5am:is (eql
                   nil
                   (parse-fmode-str "-rZxr-xr-x" *fmode-bits*))))

(5am:test parse-line-as-ls1r--test1
          (5am:is (equalp
                   nil
                   (parse-line-as-ls1r (make-<parsed-lines>)
                                       ""))))

(5am:test parse-line-as-ls1r--test2
          (5am:is (equalp
                   (make-<parsed-lines>
                    :dir-from-final-slash t
                    :as-ls1r (list (make-<parsed-line> :format :ls1r :fname ".." :fsobj :dir)
                                   (make-<parsed-line> :format :ls1r :fname "../file 1" :fsobj :file)
                                   (make-<parsed-line> :format :ls1r :fname "../Sub Dir" :fsobj :dir)
                                   (make-<parsed-line> :format :ls1r :fname "../Sub Dir/file2" :fsobj :file)
                                   (make-<parsed-line> :format :ls1r :fname "../Sub Dir/A" :fsobj :dir)
                                   (make-<parsed-line> :format :ls1r :fname "../Sub Dir/file3" :fsobj :file)
                                   (make-<parsed-line> :format :ls1r :fname "../Sub Dir/A" :fsobj :dir)
                                   (make-<parsed-line> :format :ls1r :fname "../Sub Dir/A/file 4" :fsobj :file))
                    :ls1r-state (make-<ls1r-state>
                                 :dir "../Sub Dir/A"
                                 :fname-hashes
                                 (hash-literal
                                  ".." 0
                                  "../file 1" 1
                                  "../Sub Dir" 2
                                  "../Sub Dir/file2" 3
                                  "../Sub Dir/A" 4
                                  "../Sub Dir/file3" 5
                                  "../Sub Dir/A/file 4" 6)))
                   (let (;;(*dbg-cond* t)
                         (pls (make-<parsed-lines>)))
                     (parse-line-as-ls1r pls "..:")
                     (parse-line-as-ls1r pls "'file 1'")
                     (parse-line-as-ls1r pls "'../Sub Dir':")
                     (parse-line-as-ls1r pls "file2")
                     (parse-line-as-ls1r pls "A")
                     (parse-line-as-ls1r pls "file3")
                     (parse-line-as-ls1r pls "'../Sub Dir/A':")
                     (parse-line-as-ls1r pls "'file 4'")
                     pls))))

(5am:test parse-line-as-ls1rl--test1
          (5am:is (equalp
                   nil
                   (parse-line-as-ls1rl (make-<parsed-lines>)
                                        ""))))

(5am:test parse-line-as-ls1rl--test2
          (5am:is (equalp
                   (make-<parsed-lines>
                    :dir-from-final-slash t
                    :as-ls1rl (list (make-<parsed-line> :format :ls1rl :fname ".." :fsobj :dir)
                                    (make-<parsed-line> :format :ls1rl :fname "../*" :fsobj :file :fmode 33188)
                                    (make-<parsed-line> :format :ls1rl :fname "../$" :fsobj :file :fmode 33188)
                                    (make-<parsed-line> :format :ls1rl :fname "../Sub Dir_" :fsobj :dir)
                                    (make-<parsed-line> :format :ls1rl :fname "../Sub Dir" :fsobj :dir)
                                    (make-<parsed-line> :format :ls1rl :fname "../Sub Dir/file1" :fsobj :file :fmode 33188)
                                    (make-<parsed-line> :format :ls1rl :fname "../Sub Dir/Dir ' X" :fsobj :dir :fmode 16877)
                                    (make-<parsed-line> :format :ls1rl :fname "../Sub Dir/my app" :fsobj :file :fmode 33261)
                                    (make-<parsed-line> :format :ls1rl :fname "../Sub Dir/A" :fsobj :dir)
                                    (make-<parsed-line> :format :ls1rl :fname "../Sub Dir/A/file2" :fsobj :file :fmode 33188)
                                    (make-<parsed-line> :format :ls1rl :fname "../Sub Dir/A/file3" :fsobj :file :fmode 33188)
                                    (make-<parsed-line> :format :ls1rl :fname "../Sub Dir/C" :fsobj :dir)
                                    )
                    :ls1rl-state (make-<ls1rl-state>
                                  :dir "../Sub Dir/C"
                                  :fname-hashes
                                  (hash-literal
                                   ".." 0
                                   "../*" 1
                                   "../$" 2
                                   "../Sub Dir_" 3
                                   "../Sub Dir" 4
                                   "../Sub Dir/file1" 5
                                   "../Sub Dir/Dir ' X" 6
                                   "../Sub Dir/my app" 7
                                   "../Sub Dir/A" 8
                                   "../Sub Dir/A/file2" 9
                                   "../Sub Dir/A/file3" 10
                                   "../Sub Dir/C" 11)))
                   (let (;;(*dbg-cond* t)
                         (pls (make-<parsed-lines>)))
                     (parse-line-as-ls1rl pls "..:")
                     (parse-line-as-ls1rl pls "total 123")
                     (parse-line-as-ls1rl pls "-rw-r--r-- 1 alex alex      0 Dec 19 09:36 '*'")
                     (parse-line-as-ls1rl pls "-rw-r--r-- 2 alex alex      1 Dec 19 09:36 '$'")
                     (parse-line-as-ls1rl pls "'../Sub Dir_':")
                     (parse-line-as-ls1rl pls "total 123")
                     (parse-line-as-ls1rl pls "")
                     (parse-line-as-ls1rl pls "'../Sub Dir':")
                     (parse-line-as-ls1rl pls "total 123")
                     (parse-line-as-ls1rl pls "-rw-r--r-- 1 alex alex     12 Dec 19 09:36 file1")
                     (parse-line-as-ls1rl pls "drwxr-xr-x 1 alex alex      0 Dec 19 09:36 \"Dir ' X\"")
                     (parse-line-as-ls1rl pls "-rwxr-xr-x 1 alex alex   9999 Dec 19 09:36 'my app'")
                     (parse-line-as-ls1rl pls "'../Sub Dir/A':")
                     (parse-line-as-ls1rl pls "total 123")
                     (parse-line-as-ls1rl pls "-rw-r--r-- 1 alex alex     34 Dec 19 09:36 file2")
                     (parse-line-as-ls1rl pls "-rw-r--r-- 1 alex alex   1234 Dec 19 09:36 file3")
                     (parse-line-as-ls1rl pls "'../Sub Dir/C':")
                     (parse-line-as-ls1rl pls "total 123")
                     (parse-line-as-ls1rl pls "")
                     pls))))

(5am:test parse-line--test1
          (5am:is (eql
                   :ls1r
                   (let (;;(*dbg-cond* t)
                         (pls (make-<parsed-lines>)))
                     (parse-line pls "..:")
                     (parse-line pls "'file 1'")
                     (parse-line pls "'../Sub Dir':")
                     (parse-line pls "file2")
                     (parse-line pls "A")
                     (parse-line pls "file3")
                     (parse-line pls "'../Sub Dir/A':")
                     (parse-line pls "'file 4'")
                     (<parsed-lines>-detected-format pls)))))

(5am:test parse-line--test2
          (5am:is (eql
                   :ls1rl
                   (let ((*dbg-cond* t)
                         (pls (make-<parsed-lines>)))
                     (parse-line pls "..:")
                     (parse-line pls "total 1")
                     (parse-line pls "-rw-r--r-- 1 alex alex      0 Dec 19 09:36 '*'")
                     (parse-line pls "-rw-r--r-- 2 alex alex      1 Dec 19 09:36 '$'")
                     (parse-line pls "'../Sub Dir_':")
                     (parse-line pls "total 2")
                     (parse-line pls "")
                     (parse-line pls "'../Sub Dir':")
                     (parse-line pls "total 3")
                     (parse-line pls "-rw-r--r-- 1 alex alex     12 Dec 19 09:36 file1")
                     (parse-line pls "drwxr-xr-x 1 alex alex      0 Dec 19 09:36 \"Dir ' X\"")
                     (parse-line pls "-rwxr-xr-x 1 alex alex   9999 Dec 19 09:36 'my app'")
                     (parse-line pls "'../Sub Dir/A':")
                     (parse-line pls "total 4")
                     (parse-line pls "-rw-r--r-- 1 alex alex     34 Dec 19 09:36 file2")
                     (parse-line pls "-rw-r--r-- 1 alex alex   1234 Dec 19 09:36 file3")
                     (parse-line pls "'../Sub Dir/C':")
                     (parse-line pls "total 5")
                     (parse-line pls "")
                     (<parsed-lines>-detected-format pls)))))

(5am:test extract-ls-fname--test1
          (5am:is (equal
                   '(fail . "empty path")
                   (extract-ls-fname ""))))

(5am:test extract-ls-fname--test2
          (5am:is (equal
                   '(fail . "unclosed ' on 4")
                   (extract-ls-fname "aaa'bb"))))

(5am:test extract-ls-fname--test3
          (5am:is (equal
                   '(fail . "unclosed \" on 4")
                   (extract-ls-fname "aaa\"bb"))))

(5am:test extract-ls-fname--test4
          (5am:is (equal
                   '(fail . "unescaped shell special character '$' on 4")
                   (extract-ls-fname "aaa$"))))

(5am:test extract-ls-fname--test5
          (5am:is (equal
                   '(fail . "EOF while unescaped shell special character '$' on 1")
                   (extract-ls-fname "$aaa"))))

(5am:test extract-ls-fname--test6
          (5am:is (equal
                   '(fail . "unescaped string special character '$' on 5")
                   (extract-ls-fname "\"aaa$\""))))

(5am:test extract-ls-fname--test7
          (5am:is (equal
                   '(fail . "EOF while unescaped string special character '$' on 1")
                   (extract-ls-fname "$\""))))

(5am:test extract-ls-fname--test8
          (5am:is (equal
                   '(fname . "abc")
                   (extract-ls-fname "abc"))))

(5am:test extract-ls-fname--test9
          (5am:is (equal
                   '(fname . "abc def")
                   (extract-ls-fname "abc\\ def"))))

(5am:test extract-ls-fname--test10
          (5am:is (equal
                   '(fname . "abc$def")
                   (extract-ls-fname "abc\\$def"))))

(5am:test extract-ls-fname--test11
          (5am:is (equal
                   '(fname . "abc def")
                   (extract-ls-fname "'abc def'"))))

(5am:test extract-ls-fname--test12
          (5am:is (equal
                   '(fname . "abcdef")
                   (extract-ls-fname "'abc''def'"))))

(5am:test extract-ls-fname--test13
          (5am:is (equal
                   '(fname . "abc def")
                   (extract-ls-fname "\"abc def\""))))

(5am:test extract-ls-fname--test14
          (5am:is (equal
                   '(fname . "abcdef")
                   (extract-ls-fname "\"abc\"\"def\""))))

(5am:test extract-ls-fname--test15
          (5am:is (equal
                   '(fname . "abcdef")
                   (extract-ls-fname "xyz \"abc\"\"def\""))))

(5am:test extract-ls-fname--test16
          (5am:is (equal
                   '(fname . "\"")
                   (extract-ls-fname "'\"'"))))

(5am:test extract-ls-fname--test17
          (5am:is (equal
                   '(fname . "'")
                   (extract-ls-fname "\"'\""))))

(5am:test extract-ls-fname--test18
          (5am:is (equal
                   '(fname . "..")
                   (extract-ls-fname ".."))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Command line ;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun cli-tests-handler (cmd)
  (declare (ignorable cmd))
  (uiop:symbol-call :fiveam :run! :suite1))
  ;; (sijo-doctest:test :ros.script.easytree))

(defun cli-convert-cmd-handler (cmd)
  (declare (ignorable cmd)))

(defun cli-convert-cmd-opts ()
  (list
   (clingon:make-option
    :choice
    :description "Input format (from)"
    :short-name #\f
    :long-name "from"
    :key :from
    :items +fmt+)
   (clingon:make-option
    :choice
    :description "Output format (to)"
    :short-name #\t
    :long-name "to"
    :key :to
    :items +fmt+)
   (clingon:make-option
    :string
    :description "Strip paths by PREFIX (N dirs, string dir)"
    :short-name #\s
    :long-name "strip"
    :key :strip)
   (clingon:make-option
    :string
    :description "Prepend paths with common directory-prefix"
    :short-name #\p
    :long-name "prepend"
    :key :prepend)))

(defun cli-tests-cmd ()
  (clingon:make-command
   :name "tests"
   :usage "<no args>"
   :description "Run tests"
   :handler #'cli-tests-handler))

(defun cli-convert-cmd ()
  (clingon:make-command
   :name "convert"
   :usage "[-f FMT] -t FMT [-s N,DIR] [-p DIR]" ;; --strip DIR/<int> --rebase DIR
   :examples '(("Convert from one format to another:" . "ls|convert -f LS -t TREE -")
               ("Convert from unknown format to another:" . "tree|convert -t TREE -")
               ("Convert from unknown format to another:" . "tree|convert -f AUTO -t FIND -"))
   :description "Convert a tree from one format to another one"
   :handler #'cli-convert-cmd-handler
   :options (cli-convert-cmd-opts)))


(defun cli-main-cmd (argv0)
  (declare (ignorable argv0))
  (clingon:make-command
   :name "tree"
   :description "File system tree"
   :version "0.1.0"
   :authors '("John Doe <john.doe@example.org>")
   :license "BSD 2-Clause"
   :sub-commands (list (cli-convert-cmd) (cli-tests-cmd))
   :handler (lambda (cmd)
              (format t "No known subcommand provided!~%~%")
              (clingon:print-usage cmd *standard-output*)
              (uiop:quit 1))))


;; convert -f AUTO|FIND|LS|TREE -t FIND|LS|TREE
;; union|intersect|diff|uniq -f AUTO|FIND|LS|TREE -f AUTO|FIND|LS|TREE
;; over -f AUTO|FIND|LS|TREE -t FIND|LS|TREE -c <CMD>|ENSURE|DELETE

(defun full-argv ()
  (or
   #+sbcl sb-ext:*posix-argv*
   #+clisp ext:*args*
   #+cmu extensions:*command-line-words*
   #+allegro (sys:command-line-arguments)
   #+lispworks system:*line-arguments-list*
   nil))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Main ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun process-argv (argv)
  (let* ((fargv (full-argv))
         (buf (make-string 3))
         (arg0-file-header (handler-case ;; if we cannot read, return fake 3 item string
                            (with-open-file (strm (car argv) :direction :input)
                              (and (read-sequence buf strm) buf))
                             (error () (make-string 3)))))
    (cond ((string= "#!/" (subseq arg0-file-header 0 3)) (list :script (car argv)))
          (t (list :binary (car fargv))))))


(defun main (&rest argv)
  (let* ((*OS* (det-*OS*))
         (*path-sep* (det-*path-sep*))
         (qual-argv (process-argv argv))
         (fixed-argv (ecase (car qual-argv)
                       (:script (rest argv))
                       (:binary argv))))
    (clingon:run (cli-main-cmd (nth 1 qual-argv)) fixed-argv)))

;;; vim: set ft=lisp lisp:
